\chapter*{\ref{part:base}部の流れ}
\ref{chap:secret}章では共通鍵暗号を軽く紹介し、情報理論的安全性と計算量的安全性という考え方を説明します。
それからブロック暗号やその使い方について触れます。
SSL3.0に対する攻撃として話題になったPOODLEにも簡単に触れます。

\ref{chap:rand}章では暗号に必要な乱数の紹介をし、\ref{chap:public}章で公開鍵暗号の話に入ります。
公開鍵暗号（特にElGamal暗号）は本書のメインですので詳しく紹介します。

それから公開鍵暗号への攻撃方法や求められる安全性について説明します。
RSA暗号も軽く紹介し、よく説明されている通常の方法は必ずしも安全ではないことを示します。
最後に公開鍵暗号を利用するために必要な公開鍵基盤（PKI）について紹介します。

\ref{chap:authentication}章では認証の話をします。
ハッシュ関数に求められる性質を紹介した後、メッセージ認証の話をします。
HMACではよくある間違いに対する攻撃の紹介をしてからデジタル署名に触れます。
それからブラインド署名や部分ブラインド署名というちょっと変わった署名も紹介します。

\ref{chap:ec}章では\ref{part:base}部の二つ目の山場である楕円曲線暗号の話をします。
\ref{chap:public}章で紹介したElGamal暗号の話が楕円曲線を使って同じように進むことを紹介します。
またアメリカの国家安全保障局の盗聴問題で注目度が増えた前方秘匿性（PFS）についても紹介します。

\ref{chap:group}章では群の話をします。
群とは有限体上の暗号と楕円曲線上の暗号を統一的に考えるための枠組みです。
多少抽象的になるので最初はとっつきにくいかもしれません。

\chapter{共通鍵暗号}
\label{chap:secret}
この章では共通鍵暗号について紹介します。
共通鍵暗号は2000年以上前からあったとされる歴史の長いものです。

\section{暗号}
暗号（化）とは、私とあなたとのやりとりを他人が盗み見しても、その内容を知られないようにするやり方です。
本書では公開されたある手順にしたがって、あるメッセージを元がわからないものに置き換える方法を対象とします。
暗号化する前のメッセージを平文（ひらぶん）、暗号化されたメッセージを暗号文といいます。
暗号文を元の平文に戻す操作を復号といいます。
復号するときに使う情報を秘密鍵といいます。秘密鍵は他人に知られてはいけません。

暗号技術の中には、そもそもやりとりをしていることを悟られないようにする方法もあります。
大事なデータを音声や映像の中に隠蔽（いんぺい）する技術でステガノグラフィと呼ばれます。
データの著作権を管理するための電子透かしなどに使われます。

また暗号化の手順を公開せずに秘密にしておくというやり方もあります。
ただ手順自体を秘密にする方法は、その方法がいつか漏れてしまう可能性、あるいはその方法が安全なのか第三者の目で検証できないという点であまり勧められません。

情報を安全に扱うためには他人に情報を見えないようにするだけでは不十分です。
もらった情報が正しいものか、あるいは他人がなりすましていないかを検証できることも必要です。
それらの手法を含めたものを総称して暗号技術、暗号プロトコルということがあります。
略して単に暗号ということもあります。
文脈によって指している対象が異なることがありますので、ご注意ください。

\section{古典的な方法}
古代ローマでも使われていたとされる古典的な暗号として、文字をずらす方法があります。
たとえば文章中のアルファベットを一つ前にするという規則です。
変換する前の大文字小文字の情報は残しておきましょう。
たとえば\texttt{H}なら\texttt{G}、\texttt{e}なら\texttt{d}です。
また一番前の\texttt{A}は\texttt{Z}にするとします。
すると\texttt{Hello IBM}は\texttt{Gdkkn HAL}になります。
このメッセージを受け取った人は一文字後ろにして\texttt{Hello IBM}に戻します。
\image{caesar.pdf}{一文字ずらしの暗号}
小さいころに秘密のやりとりの遊びでやってみた方もいらっしゃるのではないでしょうか。
この場合、ずらす方法が暗号方式、\texttt{Hello IBM}が平文、\texttt{Gdkkn HAL}が暗号文、ずらす文字数が秘密鍵にあたります。

ただこのような文字をずらすだけの方法は容易に破られてしまいます。
たとえば英語では\texttt{e}の出現頻度が高い、\texttt{q}の後ろはほとんど\texttt{u}などの統計的な特徴があります。
文字をずらすだけでは文字の頻度の分布は暗号文にも残ります。
すると暗号文の中の頻度の高い文字は\texttt{e}だろうという予想を立ててずらされている文字数を推測されてしまいます。
このように暗号文から元の平文や秘密鍵を見つけることを解読するといいます。
現在広く使われている暗号は、たとえ平文のデータに偏りがあったとしてもその暗号文には統計的な偏りが出ないように設計されています。

\section{Vernam暗号と情報理論的安全性}
\label{seq:vernam}
Vernam（バーナム）暗号は絶対に破られないことが保証されている暗号です。
ワンタイムパッド（one-time pad）とも呼ばれます。
長さ$n$ビットの平文$m$を暗号化するときは長さ$n$ビットの乱数$r$を作ります。
乱数については\ref{chap:rand}章で紹介します。
ここではサイコロを振り、出た目が偶数なら0、奇数なら1とする操作を$n$回繰り返して$r$を作りましょう。
$r$を秘密鍵とします。
それから$m$と$r$のビットごとの排他的論理和（$\oplus$）を使って$\Enc(m):=m \oplus r$とします。
排他的論理和は、0と1の演算を
\begin{align*}
& 0 \oplus 0 = 0,\\
& 0 \oplus 1 = 1,\\
& 1 \oplus 0 = 1,\\
& 1 \oplus 1 = 0
\end{align*}
という規則で計算します。
同じ値同士の排他的論理和は0で、異なる値同士なら1です。
$a$, $b$, $c$が0か1のいずれでも$(a \oplus b) \oplus c = a \oplus (b \oplus c)$が成り立ちます。
たとえば平文が9（2進数表記で\texttt{0b1001}と書く）で乱数が13（\texttt{0b1101}）とします。
暗号文は各桁のビットごとに排他的論理和をとるので
\[
9 \oplus 13 = \texttt{0b1001} \oplus \texttt{0b1101} = \texttt{0b0100} = 4
\]
です。
2進数に変換する方法は\ref{binary-method}節で紹介します。
復号は同じ乱数を使って再度排他的論理和をとります。
すると
\[
(m \oplus r) \oplus r = m \oplus (r \oplus r) = m \oplus 0 = m
\]
と元の平文に戻ります。

これがどうして絶対破られないとされているのか、簡単な場合で考えてみましょう。
長さ1ビットの平文を暗号化してみます。
平文$m$は0か1のどちらかです。
乱数$r$も0か1のどちらかです。
すると$\Enc(m)$も0か1のどちらかです。

$\Enc(m)$が0だったときに$m$を推測してみましょう。
乱数$r$が0なら$m=0$、$r=1$なら$m=1$です。$r=0$の確率が$1/2$なら$m=0$の確率も$1/2$です。
これでは$\Enc(m)$を知らなくても、当てずっぽうで$m=0$と推測したときに当たる確率と変わりません。
平文の長さが2ビットなら0, 1, 2, 3の4通りで乱数$r$も4通りです。
どのパターンが出る確率も等しく当てずっぽうで当たる確率は$1/4$です。
ビット長が1増えるごとに平文の種類は2倍になります。
したがって長さが$n$ビットなら平文、乱数の種類は共に$2^n$通りで
どのパターンが出る確率も等しく$1/2^n$です。

どんなビット長でも$\Enc(m)$を知ったときに$m$が当たる確率が、$\Enc(m)$を知らずに当てずっぽうで当たる確率と同じなので絶対破れないと書きました。
このような安全性を持つ暗号を情報理論的安全であるといいます。
どんなに高性能な計算機を使ってもこの状態は変わりません。

しかしVernam暗号が使われることはあまりありません。
たとえ安全に$m$を暗号化できたとしても、それを復号するための秘密鍵$r$をどうやって相手に送るかという問題があるからです。
元の平文と同じ長さの乱数が必要なのですから、問題が$m$から$r$に変わっただけという考え方もできます。

\section{共通鍵暗号}
暗号化するときに使う鍵と復号するときに使う鍵が同じである暗号方式を共通鍵暗号といいます。
秘密鍵暗号や対称鍵暗号とも呼ばれます。
前述の文字をずらす方法やVernam暗号は共通鍵暗号の一種です。

Vernam暗号は秘密鍵の長さと平文の長さは同じでした。
それでは使いにくいので、秘密鍵を小さい固定長にした共通鍵暗号が一般的に使われています。

共通鍵暗号は大きく分けてブロック暗号とストリーム暗号の2種類に分類されます。
ブロック暗号は、たとえば平文を128ビットのブロックに分けて、そのブロック単位で暗号化します。
平文の長さがブロック長の倍数でないときはパディングと呼ばれる長さ調整が必要です。

たとえば平文の長さを50, ブロック長を16とすると、$50 / 16 = 3$余り$2$なので最後のデータに14個ダミーのデータを追加して一つのブロックにします。
単に追加すると平文の正しい長さが判らなくなってしまうので、先に追加したダミーの長さを記す、あるいはデータの終端記号を追加してから残りをダミーで埋めることが多いです。

それに対してストリーム暗号は、ビット（あるいはバイト）単位で平文を処理する暗号方式です。
通常パディング操作は不要です。

現在ではブロック暗号が主流です。
これはブロック暗号に対する暗号の安全評価の研究の方が進んでいるためです。
また\ref{CTR}節で紹介する方法を使うとブロック暗号を使ってストリーム暗号を構成できます。
ブロック暗号にはアメリカ合衆国標準のAES、NTTと三菱電機が共同で開発したCamelliaなどがあります。
ソニーが開発したブロック暗号CLEFIAは省電力なハードウェアでも動作する軽量暗号（Lightweight Cryptography）の国際標準規格ISO/IEC 29192の一つに採用されています。

\section{ブロック暗号と計算量的安全性}
\label{sec:compute}
ブロック暗号などの秘密鍵の大きさが小さい固定長の暗号は扱いやすいです。
しかしその代わりVernam暗号の持っていた情報理論的安全性は失われています。
なぜならある暗号の秘密鍵の長さが$n$ビットだったとします。
\ref{seq:vernam}節で書いたようにこの秘密鍵の種類は$2^n$通りです。
したがって平文の長さが$n$よりずっと長かったとしても最大$2^n$通り試せばその暗号を破れます（今はどの答えが正しいのかの判定方法を考慮しません）。
これを総当たり攻撃といいます。

たとえば平文の長さが1024ビットとします。
Vernam暗号の場合、平文の候補が$2^{1024}$通りどれも対等にありえます。
しかし、秘密鍵の長さが64ビットのブロック暗号を使った場合、平文の候補は高々$2^{64}$通りしかありません。
Vernam暗号に比べてずっと少ないのです。

ある暗号の攻撃に必要な計算量が$2^n$のとき、$n$ビットセキュリティを持つといいます。
ブロック暗号では総当たり攻撃よりも効率のよい攻撃法が見つかっていないものが望ましいです。
つまり$n$ビット鍵長の理想のブロック暗号は$n$ビットセキュリティを持ちます。

たとえば鍵長が128ビットのときは鍵の種類が$2^{128} = 3.4 \times 10^{38}$個あります。
一つずつ正しい鍵か確認する場合、1秒間に1京（=$10^{16}$）回確認できたとしても、
全部調べるのに1000兆年かかります。
鍵長が256ビットのブロック暗号だと$3.6 \times 10^{53}$年です。
宇宙の年齢とされる138億（$=1.38 \times 10^{10}$）年よりもずっと大きい数字ですね。
最近は128ビットセキュリティ以上の安全性を持つものが望ましいとされています。

このように暗号の攻撃に必要な計算量を見積もり、それよりも少ない計算量では解けないと定義された安全性を計算量的安全性といいます。

\section{暗号の危殆化}
計算量的安全性を持つ暗号は、計算機の進歩や解読アルゴリズムの改良に伴い、その安全性は弱くなります。
ある暗号が当初想定されていたよりも少ないコストで解読できるようになることを暗号の危殆化（きたいか）といいます。

ここで暗号という言葉は共通鍵暗号だけでなく、これから紹介する公開鍵暗号やハッシュ関数などの広い意味での暗号技術を指します。
暗号の危殆化は秘匿性（ひとくせい）や認証に関わる重要な問題です。
そこでどの暗号が安全でどの暗号が危ないのかといった情報の収集と評価を行っている専門的な機関があります。
日本ではCRYPTREC（CRYPTography Research and Evaluation Committees）
\footnote{\url{http://www.cryptrec.go.jp/}}
やCELLOS（Cryptographic protocol Evaluation toward Long-Lived Outstanding Security Consortium）
\footnote{\url{https://www.cellos-consortium.org/jp/}}
などの機関です。他にも一般向けに注意喚起するサイトがあります。
重要なデータを扱うサーバ管理者は日頃からそれらが提供する情報に触れておくとよいでしょう。

たとえば昔よく使われていたブロック暗号DESやハッシュ関数MD5は使ってはいけません。
今でも使われているハッシュ関数SHA-1、公開鍵暗号RSA暗号の1024ビット版も近い将来破られると考えられています。
危殆化した暗号技術は攻撃の耐性を上げるために鍵長を増やすか、増やせないならより安全なものに置き換えなければなりません。
現在2048ビットRSA暗号や128ビットAESが使われています。
これらの安全性はせいぜい数十年とされています。
50年後も安全かというと恐らくそうではありません。

インターネット上の買い物ならそのときの相手が正しいことを確認できて、クレジットカードの番号を秘密にかつ改竄（かいざん）されずに送受信できれば十分です。
ですから使用する暗号が当面安全なら特に問題はありません（購買履歴が将来漏洩（ろうえい）する可能性はあります）。
クラウドサービスは利用したいけれども全面的に信用できるわけではないから手元でコンテンツを暗号化してアップロードしているという方がいらっしゃるかもしれません。
しかしサービス提供者、あるいは誰かがその暗号化されたデータを盗聴して保持し20年後に解読してしまう可能性を知っておく必要があります。

たとえば自分のゲノム情報を70年間は絶対に秘密にしたいと思ったとき、どんな暗号を使えばよいのか。
それに対する明確な答えは今のところ無いように思います。

\section{計算量の指標}
\ref{sec:compute}節では長さ$n$ビットの鍵は$2^n$個なので総当たり攻撃に必要な計算量は$2^n$と書きました。
これは1回の演算量がどれぐらいかを考慮していません。
1回あたり10なのか、あるいは1000なのかによって実際の値は変わってきます（そもそも単位を書いていませんでした）。
ただ100倍違ったとしても$10^{53}$年でも$10^{55}$年でも「解けない」ことには変わらないですね。
また計算量が$1000 \times n^2$と$2^n$とでは、$n$が小さいときは前者が大きいですが、$n$が大きくなると後者の方がずっと大きくなります。

このように$n$が大きくなったときに、対象となる計算量がどのように変化するのかについて定数倍を無視して概要を知りたいことがあります。
このとき$O$記法（オー記法）というものを使います。
$f$, $g$を$x \in \RR$に関する実数値関数とします。
十分大きい$x$に対して$|f(x)|$がせいぜい$|g(x)|$の定数倍にしかならないとき、$f$のオーダーは$O(g(x))$であるといいます。

たとえば、$f(x)=3x^3+5x-5$なら$x$が十分大きいときは$3x^3$の項が効いてきます。
\[
\lim_{x \rightarrow \infty}|f(x)/x^3| =3.
\]
ですから$f(x)$のオーダーは$O(x^3)$です。
先ほどの$n$ビットセキュリティで必要な計算量は$O(2^n)$です。

\section{決定的アルゴリズムの問題点}
\label{sec:determin}
あるアルゴリズムにおいて入力が決まれば常に同じ結果を出力するとき、そのアルゴリズムを決定的といいます。
これとは対照的に、同じ入力であっても実行するたびに異なる値になる可能性があるとき、そのアルゴリズムを確率的といいます。
確率的アルゴリズムは乱択アルゴリズムともいわれます。
もちろん異なる値といってもでたらめな値ではありません。アルゴリズムの目的に応じて適切な値が得られます。

高校までで習うほとんどのアルゴリズムや公式は決定的だと思います。
やるたびに結果が変わると困るからです。
身近な確率的アルゴリズムの例として、円周率を求めるモンテカルロ法があります。
1辺の長さが2の正方形の中に半径の長さが1の円を書きます。
正方形の中にでたらめに沢山点をうち、円の中に入った個数を数えます。
打った点の総数と円の中に入った点の数との比から円周率を求める方法です。
このアルゴリズムを実際にやってみたら、沢山回数を重ねてもなかなか$3.1$にすらならない経験をされた方もいらっしゃるかもしれません。

AESなどのブロック暗号は同じ秘密鍵と平文を与えた場合、常に同じ暗号文を出力します。
つまりブロック暗号は決定的アルゴリズムです。

暗号が決定的だとちょっと困ったことが起こります。
たとえばAさんは入札に参加していたとします。
Aさんは入札額10万円をブロック暗号で暗号化して暗号文$c$として先方に送っていました。
Aさんが無事落札し、入札額10万円が公開されます。
するとAさんの通信を盗聴していたBさんは$c$が10万円を暗号化したものだとわかります。

次に別の入札でAさんがまた10万円で入札しようとしました。
暗号文は同じ$c$です。
するとBさんは$c$を見てAさんの入札額がわかり、自分は10万1円で落札してしまったのです。

したがってブロック暗号を決定的なまま使ってはいけません。

\section{CBCモードと初期化ベクトル}
\label{CBC}
前節ではブロック暗号は決定的アルゴリズムなのでそのまま使ってはいけないと説明しました。
同じ平文が常に同じ暗号文になるのが問題なので、そうならないような使い方をすべきです。
その方法はいくつかあるのですが、ここではCBC（Cipher Block Chaining）モードを紹介します。
CBCモードはインターネットで安全に通信するためのプロトコルであるSSL（Secure Sockets Layer）で使われています。

CBCモードは平文をブロック（たとえば16バイト）ごとに暗号化する際に、一つ前のブロックの暗号文と排他的論理和をとってから暗号化する方法です。
先頭ブロックの一つ前は存在しないのでダミーのブロックをランダムに生成して使います。
このブロックを初期化ベクトル（Initialization Vector）、略してIVといいます。
IVは暗号文といっしょに他人に見える形で送ります。
\image{cbc.pdf}{CBCモードの暗号化}
IVが異なると同じ平文$m$でも暗号文$c$が異なるのでより安全になります。

復号は暗号文を復号した後一つ前の暗号文と排他的論理和をとって平文に戻します。
先頭のブロックでは一つ前の暗号文の代わりにIVを使います。
\image{cbc-dec.pdf}{CBCモードの復号}

\section{パディングオラクル攻撃}
\label{POD}
CBCモードは平文$m_i$は一つ前の暗号文$c_{i-1}$との排他的論理和をとっています。
したがって$c_{i-1}$のどれか1ビットを変更すると、対応する$m_i$の1ビットが変わります。
これは通常問題になることはありません。
しかし2002年にブロック暗号のパディング処理と組み合わせた攻撃の発表がありました~\cite{eurocrypt-2002-2850}。

それは次のような攻撃です。
ブロック暗号はデータをブロックサイズに合わせるためにパディング処理が必要でした。
攻撃したい暗号文にわざと不正なパディングを追加してサーバに送ります。
するとサーバがそれを受け入れるかエラーで弾くかします。
そのサーバの返答を使うことで秘密鍵はわからないまま元の平文の一部を得るのです。

この手法はパディングオラクル攻撃（Padding Oracle Attack）と呼ばれます。
オラクル（Oracle）とは神託（しんたく）と呼ばれる、神様が発した言葉のことです。
この場合は「攻撃者が作った暗号文は正当か不正か」という問いの答えを教えてくれるサーバの返答をオラクルに見立てています。

この攻撃を実際にするにはかなりの量の問い合わせが必要になり、発表当時は直ちに脅威となるとは考えられていませんでした。
しかし2010年にRizzo, Duongたちがより現実的な攻撃を示します~\cite{Rizzo:2010}。
更に2014年、SSL3.0の仕様の不備を使ってCBCモードに対して少ない回数でパディングオラクル攻撃ができることが示されました。
POODLE（Padding Oracle On Downgraded Legacy Encryption）と呼ばれるこの攻撃により、現在SSL3.0は使ってはいけないプロトコルとなっています。
CBCモード自体は安全なのですが、プロトコルの作り方や組み合わせ方によっては安全でなくなることがあるという重要な一例です。

\section{この章のまとめ}
共通鍵暗号の一つであるVernam暗号という乱数を使った暗号を紹介しました。
Vernam暗号は情報理論的に安全な暗号ですが、秘密鍵の大きさが平文と同じ大きさという難点があります。
そのため大抵は秘密鍵の大きさが数百ビットですむブロック暗号やストリーム暗号が使われます。
ブロック暗号は、どれぐらいの回数の計算をすれば解けるかという計算量の見積もりを用いてその安全性が決められています。
つまり計算量的安全性を持つ暗号です。

アルゴリズムには入力が同じなら常に同じ値を返す決定的なものと、その都度変わり得る確率的なものがあります。
ブロック暗号は決定的なアルゴリズムなので平文と秘密鍵が同じなら常に同じ暗号文になります。
この性質は安全性を損なうため、CBCモードなどを使って同じ平文でも異なる暗号文になるようにすべきです。
