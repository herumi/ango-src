\chapter{準同型暗号}
\label{chap:homo}
この章では準同型暗号と呼ばれる暗号とその応用について紹介します。
準同型という言葉は日常ではあまりなじみがないため難しそうに見えますが、手短に言うと暗号化したまま平文の足し算や掛け算ができる性質のことです。
足し算ができる準同型暗号を加法準同型暗号、掛け算ができる暗号を乗法準同型暗号と呼びます。
2で割った余りの世界（$\FF_2$）で足し算は排他的論理和（xor）、掛け算は論理積（and）に相当します。
この二つの操作ができると理論的に任意の演算ができます。

加法準同型暗号や乗法準同型暗号の例は昔からいくつか知られていましたが、両方の性質を満たす完全準同型暗号と呼ばれる暗号の例は長らく知られていませんでした。
2009年に初めて完全準同型暗号の構成方法が提示され、それ以降研究が活発に行われています。

\section{ElGamal暗号再び}
ElGamal暗号は$g$を公開パラメータ、秘密鍵を$x$、公開鍵$y:=g^x$を固定し、平文$m$に対して乱数$r$を選んで
\[
\Enc(m):=(c_1, c_2)=(g^r, my^r)
\]
という形の暗号化をしていました。
\ref{sec:ElGamal_weak}節で述べたようにElGamal暗号は秘密鍵や平文を知らなくても暗号文を何倍かできてしまうという弱点がありました。
その性質についてもう少し考えます。
2個の平文$m_1$, $m_2$があってそれぞれ別の乱数$r_1$, $r_2$を選んで暗号化していたとします。
\begin{align*}
& \Enc(m_1):=(g^{r_1}, m_1 y^{r_1}),\\
& \Enc(m_2):=(g^{r_2}, m_2 y^{r_2}).
\end{align*}
暗号化されたものの要素をそれぞれ掛けると$(g^{r_1+r_2}, m_1 m_2 y^{r_1 + r_2})$となります。
これは平文$m_1 m_2$を乱数$r_1+r_2$で暗号化したものとみなせます。
これを$\Enc(m_1)\Enc(m_2)$と書くことにすると
\[
\Enc(m_1)\Enc(m_2) = \Enc(m_1 m_2)
\]
が成立します。
平文$m_1$, $m_2$を暗号化したまま2個の平文の積$m_1 m_2$を得られたのでElGamal暗号は乗法準同型暗号です。

またElGamal暗号をちょっとひねってみましょう。
適当な整数$h$をとり$m$の代わりに$h^m$を暗号化してみます。
\[
\Enc'(m) := \Enc(h^m)=(g^r,h^my^r).
\]
すると2個の平文$m_1$, $m_2$に対しては
\begin{align*}
\Enc'(m_1)\Enc'(m_2)&=\Enc(h^{m_1})\Enc(h^{m_2})=\Enc(h^{m_1}h^{m_2})=\Enc(h^{m_1+m_2})\\
&=\Enc'(m_1+m_2)
\end{align*}
が成立します。
ここでこの式の右辺を形式的に$\Enc'(m_1) + \Enc'(m_2)$と書くと
\[
\Enc'(m_1) + \Enc'(m_2)=\Enc'(m_1+m_2)
\]
となります。
こちらは暗号化したまま2個の平文の和$m_1+m_2$を得られたので$\Enc'$は加法準同型暗号です。
ここで$m_1=m_2=m$とすると$\Enc'(2m)=2\Enc'(m)$が成立し、一般に任意の整数$n$に対して$\Enc'(nm)=n\Enc'(m)$も成立します。
\image{homo.pdf}{準同型暗号}
このひねったElGamal暗号を以降ではlifted-ElGamal暗号と呼びます。
lifted-ElGamal暗号には一つ注意点があります。
それは復号する場合、ElGamal暗号と同様にすると$h^m$までは求められますが、ここから$m$を求めるには離散対数問題を解かなければなりません。
これは一般には無理です。それが難しいことを仮定して暗号が作られているのですから！\,
ただし$m$がたとえば0以上1万以下の数値であるという制限があれば秘密鍵を知っている人だけが総当たりなどの手法を使うことで復号できます
（値の制限をつけても復号できるのは秘密鍵を知っている人だけです。知らない人は依然として復号できません）。

このようにlifted-ElGamal暗号は平文になんらかの制約を入れないと使えません。
そのような制約のない実用的な加法準同型暗号としては1998年に提案された岡本・内山暗号や1999年に提案されたPailler暗号などが知られています。
加法性と乗法性の両方を備えた準同型暗号を完全準同型暗号といいます。
完全準同型暗号は鍵長が数十MBからGB単位と巨大になるため今のところ実際に使うのは難しいです。

なお準同型暗号は$\Enc(m)$と公開鍵から$\Enc(2m)$を作れます。
したがって\ref{sec:ElGamal_weak}節のElGamal暗号の弱点と同様頑強性を持っていません。
公開鍵暗号と同じモデルで考える限りIND-CCA1安全なものが最良ということになります。

\section{化合物データベースの秘匿検索}
\label{chemical}
古典的ではありますが加法準同型暗号の別の応用例として2011年に提案された化合物データベースの秘匿検索技術を紹介しましょう\footnote{\textit{秘密計算による化合物データベースの検索技術} :\\ \url{http://www.aist.go.jp/aist_j/press_release/pr2011/pr20111101/pr20111101.html}}。
まず背景から説明します。
新薬の開発では効果がありそうと思われる新しい化合物に対して、それとよく似た既存の化合物の性質を調べることがよくあるそうです。
化合物はいくつかの原子の固まり（基と呼ばれる）の組み合わせからなっています。
\image{kusuri.pdf}{基の例}
図\ref{fig:kusuri.pdf}は基の一部を書いたものです。
こういったものが複雑に組み合わさって大きな化合物になっている図を見られた方も多いでしょう。
その一部を別の基に変えると性質がどう変わるかという膨大な資料（データベース）があります。
様々な用途に特化した高価なデータベースが市販されています。

さて、ここでデータベースを使いたい研究者と、データベースを売りたい販売会社との間に相反する要求があります。
研究者がどんな薬を開発しているかは企業秘密で、自分が何の化合物を調べたいか外部の人に知らせたくはありません。
しかしあるデータベースを購入する前に、そのデータベースが自分の用途にあっているかはちょっと確認してから買いたいものです。

逆に販売会社としては購入前にできるだけ中身の情報を見せたくはありません。
自分の用途にあっているかを判断する材料は、ここでは対象とした化合物の類似物がデータベース内にいくつあるかという情報とします。
つまり
\begin{itemize}
\item[(A)] クライアントは自分が何を検索しているかは知らせずにデータベース内の類似物の総数を知りたい
\item[(B)] サーバは類似物の総数以外の情報をクライアントに与えたくない
\end{itemize}
ということです。
条件(A)を諦めてクライアントが対象化合物をサーバに教えれば条件(B)は容易に実現できます。
逆に(B)を諦めてサーバがデータベースの情報を全て公開すれば条件(A)は容易に実現できます。
いかにして二つの条件を両立するかが問題です。

\subsection{Tversky指数}\label{seq:tversky}
まずこの問題を考える前に類似物の定義をしましょう。
化合物は前述したように基からなっています。
それをいくつかまとめたもう少し大きいまとまり（部分構造）を規定します。
部分構造は数百から数万種類になるときもあるそうです。
そしてある化合物が与えられたときに、その化合物が$i$番目の部分構造を持っていれば1、持っていなければ0とすることで01のビット列を得られます。
これを化合物のフィンガープリントと呼びます。
Maccs keyと呼ばれる方法では166ビットのビット列として表現するそうです。

化合物をビット列で表現できれば、2個のビット列に対して近い、遠いを定義できます。
ここではTversky指数と呼ばれる指数を紹介します。
$\alpha$, $\beta>0$を固定し、2個のビット列$\bvec{x}$, $\bvec{y}$に対して、
\[
f(\bvec{x},\bvec{y}):=\frac{|\bvec{x} \cap \bvec{y}|}{|\bvec{x}\cap \bvec{y}|+\alpha|\bvec{x}\setminus \bvec{y}|+\beta|\bvec{y}\setminus \bvec{x}|}
\]
とします。
ここで$\cap$や$\setminus$などの操作は$\bvec{x}$, $\bvec{y}$を1がたっている部分構造の集まりで表される集合に対する演算とします。
式で書くと
\begin{align*}
& |\bvec{x}|:=|\Set{i|x_i=1}|=\sum_i x_i,\\
& |\bvec{x}\cap\bvec{y}|:=|\Set{i|x_i=1 \text{ かつ } y_i=1}|=\bvec{x} \cdot \bvec{y},\\
& |\bvec{x}\setminus \bvec{y}|:=|\Set{i|x_i=1 \text{ かつ } y_i=0}|=|\bvec{x}|-|\bvec{x}\cap\bvec{y}|
\end{align*}
です。Tversky指数$f$は0以上1以下の値をとり、2個の化合物が一つも同じ部分構造を持っていなければ0、完全に一致すれば1となります。
そうすると、たとえば「指定した化合物$\bvec{x}$に対してTversky指数0.9以上のものがいくつあるか」を明確に定義できます。
$\alpha=\beta=1$のときはTversky指数の定義の分母は
\begin{align*}
\tt{分母}&=|\bvec{x}\cap\bvec{y}|+(|\bvec{x}|-|\bvec{x}\cap\bvec{y}|)+(|\bvec{y}|-|\bvec{x}\cap\bvec{y}|)\\
& = |\bvec{x}|+|\bvec{y}|-|\bvec{x}\cap \bvec{y}|=|\bvec{x} \cup \bvec{y}|
\end{align*}
なので
\[
f(\bvec{x},\bvec{y})=\frac{|\bvec{x} \cap \bvec{y}|}{|\bvec{x} \cup \bvec{y}|}
\]
となりますね。
\image{tversky.pdf}{Tversky指数の例}
もう一度やりたいことをおさらいしましょう。
クライアントがビットベクトル$\bvec{x}$、
サーバが$N$個のビットベクトル$\bvec{y_i}$を持っています。
\begin{itemize}
\item[(A)] クライアントは$\bvec{x}$をサーバに教えずに類似度が$t$（$0 \le t \le 1$）以上の$\bvec{y_i}$の個数$C=|\Set{i|f(\bvec{x},\bvec{y_i})\ge t}|$を知りたい。
\item[(B)] サーバは$C$以外の情報をクライアントに与えたくない。
\end{itemize}
ここまで定式化するとこのプロトコルは化合物の類似度検索だけでなく、様々な応用に使えそうですね。
\ref{sec:psi}節で紹介した秘匿共通集合計算の応用例ととらえることもできます。

ただ$t=1$（完全一致）としてこのプロトコルを走らせるとクライアントはサーバが$\bvec{x}$を持っているかどうかの情報を得られます。
すると何度も繰り返すとサーバの情報の一部を取得できてしまいます。
ですので実際には$t$の値に何らかの制約を入れるか問い合わせ回数の上限を入れるかなどの運用が必要でしょう。

\subsection{暗号化したままTversky指数を計算する}\label{seq:enc_tversky}

プロトコルの実現方法を考えましょう。
まずクライアントが検索対象として$\bvec{x}$を選び、サーバ側のある$\bvec{y}$に対してTversky指数を計算しようと思います。
今やりたいことはクライアント側で$\bvec{x}$を何らかの暗号化をしてサーバに送り、その状態でサーバに計算してもらうことです。
その操作に加法準同型暗号を使います。

ただこのままでは小数を含むため暗号の計算には向きません。整数のみの計算ですむように式変形をしましょう。
まず$\alpha=a/c$, $\beta=b/c$, 指定したTversky指数を$t/c$と分数で近似します。$a$, $b$, $t$は0以上の整数、$c$は正の整数とします。
$f(\bvec{x},\bvec{y}) \ge t/c$という関係式の分母を払って$|\bvec{x}\setminus \bvec{y}|=|\bvec{x}|-|\bvec{x}\cap\bvec{y}|$などを使うと
\begin{eqnarray}
R:=(c^2-tc+ta+tb)|\bvec{x} \cap \bvec{y}|-ta|\bvec{x}|-tb|\bvec{y}| \ge 0
\label{eq:tversky}
\end{eqnarray}
となります。
目標は暗号化された$\bvec{x}$が与えられたときに既知の$\bvec{y}$と式（\ref{eq:tversky}）の左辺を計算することです。
$|\bvec{x} \cap \bvec{y}|$と$|\bvec{x}|$を求められれば十分です。
平文$m$のlifted-ElGamal暗号を$\Enc(m)$とします。
$\bvec{x}:=(x_1, \dots, x_n)$の各ビットをそれぞれ暗号化したものを
$\Enc(\bvec{x}):=(\Enc(x_1), \dots, \Enc(x_n))$と書き、クライアントは$\Enc(\bvec{x})$をサーバに送ります。

加法準同型の性質を使うと
\[
\Enc(|\bvec{x}|)=\Enc(\sum_i x_i)=\sum_i \Enc(x_i)
\]
が成立し、サーバは$\Enc(|\bvec{x}|)$を計算できます。同様に$|\bvec{x}\cap\bvec{y}|$は$y_i=1$となる$i$についての$x_i$の総和なので
\[
\Enc(|\bvec{x}\cap \bvec{y}|)=\Enc(\sum_{y_i=1\text{となる}i} x_i)=\sum_{y_i=1\text{となる}i} \Enc(x_i)
\]
が成立します。$|\bvec{y}|$の値をサーバは知っているので$\Enc(|\bvec{y}|)$を計算できます。
よって式（\ref{eq:tversky}）の左辺のそれぞれの項を暗号化したまま計算できてそれらの線形和である$R_i$に対する$\Enc(R)$をサーバ側で計算できることがわかりました。

特に$|\bvec{x}\cap \bvec{y}|=\bvec{x} \cdot \bvec{y}$は0, 1ベクトルである$\bvec{x}$と$\bvec{y}$の内積なので$\Enc(|\bvec{x}\cap \bvec{y}|)$は片方のベクトルを暗号化したまま内積を求めたことになります。
そう考えるといろいろな応用ができそうですね。

$\Enc(R)$をクライアントに返して復号すれば$R \ge 0$かどうかを判別できます（$R$は$\FF_p$の元なので$0 < x < p/2$なら正、$p/2 < x < p-1$なら負とする）。
これがこのプロトコルの主要な部分です。

\subsection{サーバ側の安全性向上}\label{seq:safe_server}
\ref{seq:enc_tversky}節の方法でクライアントの情報を暗号化したまま送りました。
ただこのままではクライアントはサーバから返された各$\Enc(R_i)$の情報から$i$番目のデータがどれぐらい$x$に近いがわかってしまいます。
より安全性を高めるためにデータのかき混ぜを行います。
まず0以上の値$u_i$を$N_p$個、負の値$v_i$を$N_n$個（クライアントが復号できる範囲で）ランダムに選び、それらを暗号化します。
そして$\Set{\Enc(u_i), \dots, \Enc(v_i), \dots, \Enc(R_i), \dots}$の順序をランダムに入れ換えて、これらの集合と$N_p$の値をクライアントに返します。

クライアントは受け取った値の集合を復号し0以上である個数を数え、それから$N_p$を引くと$\bvec{x}$に類似する個数を得られます。
こうするとどの$y_i$に$R_i$が対応するのかわからなくなるためサーバから漏れる情報を減らせます。

\subsection{悪意あるクライアントへの対処}
\label{use_zkip}
\ref{seq:safe_server}節のダミーデータの追加とかき混ぜにより、サーバとクライアントの相反する要求に答えました。
ただもしクライアントがある$x_i$を0でも1でもない極端に大きい値を入れていたらどうでしょう。対応する$R_i$も極端な値となります。
たとえ$\set{R_i}$がシャッフルされていたとしてもどの$i$に対応していたのかわかってしまうかもしれません。
これを防ぐにはサーバ側で受け取った$\Enc(x_i)$に対して$x_i$が0か1のどちらかであることを確認し、そうでなければ攻撃されていると解釈してエラーにする必要があります。
もちろん$x_i$が0か1のどちらかであることはわかっても、そのどちらなのかを特定できてはいけません。
そんなことが可能なのでしょうか。

それはゼロ知識証明という手法を使うとできます。
したがって悪意あるクライアントに対処できます。
ゼロ知識証明については章を改めて紹介しましょう。
この節で秘匿検索の紹介についてはひとまず終わり、残りの節では完全準同型暗号の構成の一つについて紹介します。

\section{LWE問題}
今まで紹介した楕円曲線やペアリングとは全く異なる種類の暗号を紹介します。
それは格子をベースにした暗号です。
格子とはベクトル空間の基底をとったとき、その整数係数の線形結合で表される部分空間のことです。
近年、格子を使って完全準同型暗号や、多重線形写像、関数型暗号などが構築され注目を集めています。

LWE（Learning with Errors）問題とは誤差が入った多変数線形連立方程式を解く問題です。
以下は有限体$\FF_p$上で考えます。
$s$を$n$次元ベクトル、$e$をある確率にしたがって選ばれる$m$次元ベクトル（誤差と呼ぶ）、
$A$を$n \times m$次行列（$m \ge n$）とします。このとき

「$A$, $As + e$が与えられたときに$s$を求めよ。」\\
という問題です。今までと同様、
$m$次元ベクトル$b$をランダムに選び、

「$(A, As + e)$と$(A, b)$が与えらえたときにどちらが与えられたか判別せよ。」\\
という判別問題もあります。
誤差$e$が無い（$e=0$）なら問題は単なる線形代数です。
しかし誤差があると簡単にはいきません。
誤差はGauss分布（正規分布：\ruby{釣鐘}{つり|がね}形の分布）からとることが多いようです。

たとえば$n=2$, $m=4$,
\[
A:=
\begin{pmatrix}
1 & 2\\
2 & 1\\
4 & 1\\
7 & 4
\end{pmatrix},\quad
s:=\vvec{4}{2},\quad
e:=
\begin{pmatrix}
1 \\
-1\\
0\\
1
\end{pmatrix},\quad
x:=As+e=
\begin{pmatrix}
11\\
9\\
18\\
37
\end{pmatrix}
\]
として、$A$, $x$が与えられたとして$s:=\trans{(a,b)}$（同時に$e:=\trans{(e_1,e_2,e_3,e_4)}$も）を求めることを考えましょう。
つまり
\begin{align*}
&a+3b+e_1=11,\\
&2a+b+e_2=9,\\
&4a+b+e_3=18,\\
&7a+4b+e_4=37
\end{align*}
を解く問題です。
通常なら未知数が$2+4=6$個で方程式が4個なので解けません。
しかし$e$の成分が$\pm 1$か0しかないという情報があったとしましょう。
すると3番目の式から2番目の式を引くことで
\[
2a+e_3-e_2=9
\]
となり、$e_3-e_2$のとりうる範囲は$-2,-1,0,1,2$なので$a$は4か5.

4番目の式より$4b+e_4=37-7a$なので$a=4$なら$b=2$, $e_4=1$.
$a=5$なら$4b+e_4=2$となる$b$はありません。
よって$a=4$, $b=2$となりました。
これぐらいの規模なら$s$を求められます。
しかし変数の数が多くなると組み合わせの数が多くなります。

$p$, $n$, $m$を適切にとるとLWE問題は格子上の短い長さのベクトルを求める問題に帰着されることが知られています。
その問題の解法は現在知られている最良のものでも指数時間かかります。
量子コンピュータが登場しても解くのは難しいと思われています。
今まで紹介した楕円曲線やペアリングを使った暗号は量子コンピュータだと解けることが知られているためこれは大きな利点です。

LWEのうち演算効率がよいものとしてring-LWE（RLWE）があります~\cite{LPR10}。
これは行列の演算を環上の演算に置き換えたものです。
環とは足し算、引き算、掛け算はできるけど割り算ができるとは限らない集合でした（\ref{residue}節参照）。
たとえば6は素数ではないのでその余りの世界$\ZZ/6\ZZ:=\Set{0,1,2,3,4,5}$は体ではなく環になりました。
『イデアル格子暗号入門』（有田正剛）\cite{arita}は具体例を出しながら詳しく解説しています。

RLWEでは$n$を2の巾乗の整数とし$R:=\ZZ[x]/(x^n+1)$を考えます。
$\ZZ[x]$は$x$を変数とする整数係数の多項式全体で$\ZZ[x]/(x^n+1)$は多項式を$x^n+1$で割った余りを考えるという意味です（\ref{extend_field}節参照）。
整数係数の代わりに$\FF_p$係数の場合は$R_p:=\FF_p[x]/(x^n+1)$と書きます。
$R$の元$y$は$x^n+1$で割った多項式ですから高々$n-1$次の多項式となり、$n$個の$a_i \in \ZZ$を使って
\[
y=\sum_{i=0}^{n-1} a_i x^i
\]
と表せます。
$y$の大きさを$|y|:=\max{|a_i|}$とします。
$R$の元をある分布にしたがって選ぶというのを、$n$個の$\ZZ$の元をその分布から選ぶことと定義します。
特に平均0、標準偏差$\sigma$のGauss分布から$y$を選ぶことを$y \leftarrow \chi$と書くことにします（値は整数に丸めます）。
$R_p$の元についても同様です。

この節では$x \in \FF_p$が$p/2<x$のとき$x-p$とみなします。つまり$\FF_p$の元を$-p/2$以上$p/2$未満の整数として扱います。

RLWEは次の形になります。
$R_p$から$s$をランダムに選び、適当な回数だけ$a_i \in F_p$をランダムに、$e_i \in R_p$をある確率にしたがって選ぶ誤差としたとき、
\[
\Set{(a_i, a_i s+e_i)}
\]
が$(R_p)^2$からランダムに選んだ$(a_i,b_i)$と区別が付けられるかという問題です。
パラメータを適切に選ぶとRLWEは難しいと考えられています。

\section{RLWE仮定による完全準同型暗号}
\label{rlwe}
RLWEを使って準同型暗号（HE : Homomorphic Encryption）を構成します。
\mydescription{
\item[鍵生成]
$n$を2の巾、$p$を$p-1$が$2n$の倍数であるような素数として環$R$, $R_p$を作る。
$p$より小さい素数を$t$とする。
$R_t:=(\ZZ/t\ZZ)[x]/(x^n+1)$が平文空間となる。
$t$を$p$よりどれぐらい小さくとるかは後述します。

$s \leftarrow \chi$を秘密鍵とする。$R_p$から$a_1$をランダムに選び、$e \leftarrow \chi$を誤差と呼ぶ。
$a_0:=-(a_1 s + te)$と$a_1$を公開鍵とする。
以下の計算は$R_p$で考えます。
\item[暗号化]
平文$m \in R_t$に対して、$e_1, e_2, e_3 \leftarrow \chi$を選び、
\[
\Enc(m):=(m+a_0 e_1+t e_3,a_1 e_1+t e_2)
\]
とする。
\item[復号]
暗号文が$c:=(c_0, c_1, \dots, c_k)$の形のとき
\[
\Dec(c):=\sum_{i=0}^k c_i s^i \in R_p
\]
とする。
上記暗号化では要素が2個なのになぜここでは$k$個あるかというと、乗算するたびに暗号文の要素が増えるからです。
\item[暗号文の加算]
暗号文$c:=(c_0, \dots, c_k)$, $c':=(c'_0, \dots, c'_{k'})$に対して
$k'':=\max(k,k')$とし、短い方のベクトルに0を追加して同じ長さ$k''$のベクトルにする。
\[
\Add(c,c'):=(c_0+c'_0, \dots, c_{k''}+c'_{k''})
\]
とする。
\item[暗号文の乗算]
暗号文$c:=(c_0, \dots, c_k)$, $c':=(c'_0, \dots, c'_{k'})$に対して
\begin{align}\label{enc_product}
\hat{c}_i:=\sum_{j=0}^{i} c_j c'_{i-j}
\end{align}
とする。
これは$y$を変数として$R_p$係数の多項式としての乗算：
\[
\left(\sum_{i=0}^k c_i y^i \right)\left(\sum_{i=0}^{k'} c'_i y^i\right)=\sum_{i=0}^{k+k'} \hat{c}_i y^i
\]
を計算したことになる（係数の畳み込みと呼ばれます）。そして
\[
\Mul(c,c'):=(\hat{c}_0, \dots, \hat{c}_{k+k'})
\]
とする。たとえば$c:=(c_0,c_1)$, $c':=(c'_0,c'_1)$なら
\[
(c_0+c_1y)(c'_0+c'_1y)=(c_0c'_0)+(c_0c'_1+c_1c'_0)y+(c_1c'_1)y^2
\]
なので
\[
\Mul(c,c')=(\hat{c}_0,\hat{c}_1,\hat{c}_2)=(c_0c'_0, c_0c'_1+c_1c'_0, c_1c'_1).
\]
}
まず正しく復号できることを確認します。
\[
(c_0,c_1):=(m+a_0 e_1+t e_3,a_1 e_1+t e_2)
\]
のとき
\begin{align*}
\Dec(c)&=c_0+c_1 s = (m+a_0 e_1+t e_3)+(a_1 e_1+t e_2)s\\
&=m+(-(a_1 s + te))e_1+t e_3+a_1 e_1s+t e_2 s=m+t(-e e_1+s e_2+e_3)\\
&=m+te' \text{ ただし } e':=-e e_1+s e_2+e_3.
\end{align*}
ここで$s, e, e_1, s, e_2, e_3$は全て標準偏差$\sigma$のGauss分布から選んでいるのでそれぞれの係数は$\sigma$程度の大きさです。
したがって$e e_1$や$s e_2$も$\sigma^2$程度になり（もちろん正確には$n$にも依存します。厳密な評価はここでは省略します）、$p$を十分大きくとっておけば$|m+te'|<p/2$とできます。
そうすると、それぞれの係数を$t$で割って余りの$m$を取り出せます。
$\bmod{p}$で考えているので値が$p$を越えると$t$で割ったとき正しく値を取り出せなくなることに注意してください。
今は符号付きで考えるので$p/2$で抑えています。
\image{rlwe.pdf}{$p/2$以下なら$t$で割って$m$を取り出せる。越えると取り出し方が曖昧になる。}
このように正しい値に誤差を加えて暗号化し、復号するときにその誤差を取り除くのが格子を使った暗号の特徴です。
暗号文、$c:=(c_0, \dots, c_k)$について
\[
\varphi(c):=\sum_{i=0}^k c_i s^i
\]
としたとき、$\varphi(c)= m + te$（$e$は適当な誤差で$|m+te|<p/2$）という形になったとします。
すると、暗号文$c$と$c'$に対して
\begin{align*}
&\varphi(c)\varphi(c')=(m+te)(m'+te')=mm'+t(tee'+em'+e'm)=mm'+te'',\\
&\text{ただし } e'':=tee'+em'+e'm.
\end{align*}
$e''$の中に$t$が入っているので加算のときより大きくなりますが$|mm'+te''|<p/2$となるようにしておけば$t$で割って$mm'$を取り出せます。
つまり暗号化したまま乗算もできます。

この暗号方式では計算途中に現れる式の係数が$p/2$を越えてしまうと復号できなくなるので各種パラメータを慎重に決めなければなりません。

ここで紹介した方式は演算（特に乗算）を繰り返すと誤差の項が指数的に増大します。
誤差が$p/2$を超えないようにするためには$p$を非常に大きくしなければなりません。
あるいは演算回数に上限を設けます。
こういう制約がある準同型暗号をSHE（Somewhat HE）といいます。

SHEを使って演算回数の上限がない本当の完全準同型暗号（FHE : Fully HE）を作る方法の一つにbootstrapがあります。
それはなかなかトリッキーな手法です。

復号回路をそれ自身のSHEを使って作ります。
復号回路を作るのに必要な乗算回数が可能なようにパラメータ設定をしておきます。
暗号文$c$を復号はできるが誤差が溜まった状態とします。
そして$c$を暗号化して復号回路に入れると誤差がリセットされた状態の暗号文が出てきます。
この暗号文に対して引き続き演算をするのです。

容易に想像できますが、この処理は非常に重たいです。
しかも復号回路に必要な秘密鍵を自身の秘密鍵で暗号化して入れる必要があり、問題がややこしくなります。
したがって上限回数を極力減らす方式や誤差を取り除く回路の効率化が研究されています。

ただ実際にクラウドで使いたい場合、複数回乗算を繰り返す操作というのは多くありません。
たとえば$n$個の暗号化された値の平均値を求めるなら加算は$n$回必要ですが乗算は不要です。
$n$で割るのはクライアントですればよいからです。
この場合は加法準同型暗号だけで実現できます。

分散は加法準同型暗号だけでは求められません。
しかし乗算は各要素については1回ずつ必要ですが後は総和を取るだけです。
そのためSHEで実現できます。ベクトルの内積も分散と同じです。
\tablecap{準同型暗号の比較}{
\begin{tabular}{|c|c|c|c|c|}
\hline
           & 加算回数 & 乗算回数 & 処理性能 & 計算 \\\hline
\hline
従来の暗号 &   ×     &  ×      & ◎       & 暗号化のみ \\\hline
加法HE     & 任意回   &  ×      & ○       & 平均など \\\hline
SHE        & 十分な回数  & 数回     & △       & 分散、内積など \\\hline
FHE        & 任意回   & 任意回   & ×       & 任意の演算 \\\hline
\end{tabular}
}
そこでSHEを使った応用例が考えられています。
実際にどのようなパラメータをとるとうまくいくのかについて\cite{LNV11}では128ビットAES相当のセキュリティパラメータを使って実装実験をしています。
それによると数十KBの鍵長で実行時間も数十ミリ秒で可能とのことです。

たとえば富士通は指紋などの生体特徴データを暗号化したまま照合するシステムを提案しています~\cite{FUJITSU2013}。
ここで提案された手法は面白いテクニックを使っています。

多項式同士の乗算は畳み込み（\ref{enc_product}）と呼ばれる式になりました。
たとえば$h:=(n-1)/2$として平文$a$, $b \in R_t$を
\[
a:=\sum_{i=0}^h a_i x^i, \quad b:=\sum_{i=0}^h b_i x^i
\]
と選ぶと、その乗算$ab$の$x^h$の係数$c$は
\[
c=\sum_{i=0}^h a_i b_{h-i}
\]
です。この式は
$\vec{a}:=(a_0, a_1, \dots, a_h)$, $\vec{b}:=(b_h, b_{h-1}, \dots, b_0)$とおくと
\[
\vec{a} \cdot \vec{b} = c
\]
とみなせます。
つまりこの2個のベクトルの内積は1回の多項式の乗算でできます。
このアイデアを使って生体特徴データの照合を高速に処理しています。
またLWE仮定ではなく、最大公約数（GCD）を求める問題に誤差を入れて難しくした近似GCD問題に基づくSHEも提案されています~\cite{appGCD} \cite{CLT2014}。

\section{この章のまとめ}
暗号化されたデータの中身を知らないままで暗号化したまま足したり掛けたりできる準同型暗号を紹介しました。
準同型暗号はクラウドサービスの形態と相性がよいので盛んに研究されています。
ここでは加法準同型を用いた秘匿検索技術を紹介しました。
加法と乗法の両方が可能な完全準同型暗号（FHE）はまだ実用的とは言い難いです。
乗算回数に制約があるSomewhat準同型暗号（SHE）でも応用例は多く、こちらはそれなりの速度で動くものが登場しています。
