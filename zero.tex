\chapter{ゼロ知識証明}
\label{chap:zero}
私はある方程式の答えを知っています。
そしてあなたに私が答えを知っているということを示すことができます。
でもあなたはその答えを知らないままなのです。
ゼロ知識証明を使うとそんなことができます。

クラウドサービスでは暗号化したまま処理を行う準同型暗号が注目されています。
準同型暗号では暗号化したまま処理をするのでクラウド側が処理をさぼって適当な計算をしてもクライアントは検証できません。
正しくチェックしようとすると全ての計算を手元でしなくてはならず、クラウドに計算をさせた意味がなくなります。
少ないコストでクラウドが不正をしていないか検証できないといけません。

また、逆にクラウドは中身を見ずに計算するためクライアントが不正な値を入れているか検証できません。
そのような検証にゼロ知識証明の技術が使われることがあります。

\section{ゼロ知識証明}
ゼロ知識証明とはある人が自分の持っているある命題が真であることを、それ以外の知識を何も教えずに証明する手法です。
1985年にShafiたちが初めて定式化しました~\cite{GMR}。

ゼロ知識証明には大きく分けて二つの方式があります。
一つは対話式ゼロ知識証明と呼ばれるもので、証明したい人と、確認したい人の間で何度かデータのやりとりをすることで納得する方法です。
たとえばある合成数の素因数分解の結果を知っているということを相手に納得させる、離散対数問題の答えを知っていることを納得させるなどのやり方が提案されています。

もう一つは非対話ゼロ知識証明と呼ばれるもので、こちらは一度データを提示するだけで相手に納得させるものです。
一般にこちらの方が効率よいです。

Aさんが命題Pを知っていてBさんがそれを検証するとします。
Aさんが本当に命題Pを知っているときに検証が通ることを完全性（completeness）といいます。
逆に、検証が通れば本当にAさんが命題Pを知っていることを保証するのが健全性（soundness）です。
そして、その検証仮定で命題Pに関する情報が漏れていないことをゼロ知識性（zero knowledge）といいます。
ゼロ知識証明はこの三つの性質を持っていなければなりません。

\section{離散対数問題のゼロ知識証明}
対話式ゼロ知識証明の例として離散対数問題の答えを知っていることを示す方法を紹介しましょう。
$g$, $p$, $y$は公開情報として私Aは「$y:=g^x \in \FF_p$となる$x$を知っている」ことを$x$を教えることなく他人Bに証明する方法です。

二人の間で次の対話をします。
\begin{alignat*}{3}
&              &  \text{A（証明したい人）} & & \text{B（検証したい人）}\\
&\text{Step 1：}\quad&r\text{を選び}a:=g^r\text{を送る} &\quad \longrightarrow \quad& a\text{を受け取る}\\
&\text{Step 2：}\quad&b=0 \text{または}1\text{を受け取る} &\quad \longleftarrow \quad& 0か1を選び送る\\
&\text{Step 3：}\quad&c:=r+bx\text{を計算して送る}&\quad \longrightarrow \quad& c\text{を受け取る}\\
&\text{Step 4：}\quad& & & g^c=ay^b \text{が成り立てばOK}
\end{alignat*}

なぜこれで証明できたと思えるのか順を追って考えてみましょう。
Aが$x$を知っていれば上記手順を踏むと
\[
g^c=g^{r+bx}=g^r (g^x)^b=ay^b
\]
ですからStep 4をパスします。

Aが$x$を知らないのに答えを知っている振りはできるでしょうか。
Step 2で$b=0$が来ると予想していれば、Step 1で適当に$r$を作って$a:=g^r$を渡します。
するとStep 2で期待通り$b=0$を受け取れば$x$を知らなくても$c=r$なのでこれを送るとStep 4の
\[
g^c=g^r=a=a y^0=ay^b
\]
が成り立ちます。
しかし予想が外れて$b=1$が来るとStep 4をパスするには
\[
g^c=(g^r) y^1=g^{r+x}
\]
でなくてはなりません。
つまりStep 3で$c=r+x$を送らないといけないのですが、これは$x$を知らない人にとっては無理です。

逆にStep 2で$b=1$が来ると予想していたとしましょう。
Step 1では適当な$r'$を作って$a:=g^{r'}/y$を渡します。
Step 2で期待通り$b=1$を受け取ればStep 3では$c$として$r'$を渡します（相手をだませさえすればよいので計算手順に従う必要はないのです）。
すると
\[
g^c = g^{r'} = (g^{r'}/y) y= ay=ay^b
\]
となりStep 4をパスします。
しかし予想が外れて$b=0$が来るとStep 4をパスするには
\[
g^c=ay^b=a=g^{r'}/y=g^{r'}/g^x=g^{r'-x}
\]
でなくてはなりません。
つまりStep 3で$c:=r'-x$を送らないといけないのですが、やはりこれは$x$を知らない人にとっては無理です。

というわけで、この対話を一度だけしたときに$x$を知らないAがたまたまBの検証をパスする確率は$1/2$とわかりました。
するとこの対話を$n$回して全てパスする確率は$(1/2)^n$となります。
十分な回数の対話を繰り返せば$x$を知らない人がパスする確率は無視できるほど小さくなります。
Bは自分が納得できる回数だけ対話を繰り返せばよいでしょう。

最後にBは納得できる以外に何か$x$の情報をえられたか確認しましょう。
$b=0$を送ったときは$r$の情報をもらうだけです。
$b=1$を送ったときは$g^r$と$r+x$をもらいますが$r$がわからないので$x$もわかりません。
というわけで大丈夫なようです。
本当は「知っていること以外何も情報を与えていない」とはどういうことかを厳密に定義する必要があります。
そしてそのこのプロトコルがその定義を満たしていることも示す必要があります。
このテキストでは省略します。

またこの方法では$b$の選択肢が0と1の2種類しかありませんでしたが、選択肢を増やすことで1回でパスする確率をずっと小さくしたり、
非対話形式にしたりする方法もあります。
情報セキュリティ大学院大学公開講座の『ゼロ知識証明入門』（土井洋）はそれらの方法について丁寧に解説しています~\cite{doihiroshi}。

\section{秘匿検索におけるゼロ知識証明}
ゼロ知識証明の簡単な紹介が終わったところで\ref{use_zkip}節の悪意あるクライアントに対処する方式を紹介しましょう。
2013年に坂井氏たちによりlifted-ElGamal暗号に対する平文が0か1のどちらかであることを非対話式ゼロ式証明で確認できる方法が提案されました~\cite{SAKAI2013}。
クライアントがハッシュ関数といくつかの指数計算の組み合わせの情報を一度だけ送り、サーバ側で検証します。
前節のように検証側が納得できるまで何度もやりとりが必要なプロトコルに比べてずっと効率的です。

lifted-ElGamal暗号は$x$を秘密鍵、$g$, $h$と$y:=g^x$を公開鍵としました。
平文$m$に対して乱数$r$を用いて
\[
\Enc(m)=(c_1,c_2)=(g^r,h^m y^r)
\]
と暗号化しています。$m=0$または$m=1$に対するゼロ知識証明を次のように構成します。
$H$をハッシュ関数とします。
\mydescription{
\item[$m=0$のとき]
$r_0$, $t_1$, $s_1$をランダムに選び、
\[
R_{0,1}:=g^{r_0}, \quad R_{0,2}:=y^{r_0}, \quad R_{1,1}:=g^{s_1}/c_1^{t_1}, \quad R_{1,2}:=y^{s_1}/(c_2/h)^{t_1}
\]
とする。
\[
t:=H(R_{0,1}, R_{0,2}, R_{1,1}, R_{1,2}, c_1, c_2, h, g, y)
\]
として
$t_0:=t-t_1$, $s_0:=r_0+t_0 r$とする。
\item[$m=1$のとき]
$r_1$, $t_0$, $s_0$をランダムに選び、
\[
R_{0,1}:=g^{s_0}/c_1^{t_0}, \quad R_{0,2}:=y^{s_0}/c_2^{t_0}, \quad R_{1,1}:=g^{r_1}, \quad R_{1,2}:=y^{r_1}
\]
とする。
\[
t:=H(R_{0,1}, R_{0,2}, R_{1,1}, R_{1,2}, c_1, c_2, h, g, y)
\]
として
$t_1:=t-t_0$, $s_1:=r_1+t_1 r$とする。
}
$(c_1,c_2,t_0,t_1,s_0,s_1)$をゼロ知識証明の検証に使う値とします。

$m=0$か$m=1$であることは次のように検証します。
$(c_1,c_2,t_0,t_1,s_0,s_1)$が与えられたとき、
\[
R'_{0,1}:=g^{s_0}/c_1^{t_0}, \quad R'_{0,2}:=y^{s_0}/c_2^{t_0}, \quad R'_{1,1}:=g^{s_1}/c_1^{t_1}, \quad R'_{1,2}:=y^{s_1}/(c_2/h)^{t_1}
\]
を計算する。
\[
t':=H(R'_{0,1}, R'_{0,2}, R'_{1,1}, R'_{1,2}, c_1, c_2, h, g, y)
\]
を求めて$t=t_0+t_1$が成り立てば受理、そうでなければ棄却します。

式がとても複雑です。ここでは完全性だけ確認しましょう。
$y=g^x$, $c_1=g^r$, $c_2=h^my^r$で$(c_1,c_2,t_0,t_1,s_0,s_1)$が与えられたとします。
\mydescription{
\item[$m=0$のとき]$t_0=t-t_1$, $s_0=r_0+t_0r$なので
\begin{align*}
 & R'_{0,1}=g^{s_0}/(g^r)^{t_0}=g^{s_0-t_0 r}=g^{r_0}=R_{0,1},\\
 & R'_{0,2}=y^{s_0}/(h^m y^r)^{t_0}=y^{s_0-t_0 r}=y^{r_0}=R_{0,2},\\
 & R'_{1,1}=R_{1,1},\\
 & R'_{1,2}=R_{1,2}.
\end{align*}
\item[$m=1$のとき]$t_1=t-t_0$, $s_1=r_1+t_1r$なので
\begin{align*}
 & R'_{0,1}=R_{0,1},\\
 & R'_{0,2}=R_{0,2},\\
 & R'_{1,1}=g^{s_1}/(g^r)^{t_1}=g^{s_1-t_1 r}=g^{r_1}=R_{1,1},\\
 & R'_{1,2}=y^{s_1}/((h^m y^r)/h)^{t_1}=y^{s_1-t_1r}=y^{r_1}=R_{1,2}.
\end{align*}
}
いずれのときも$t'=t$が成り立つので受理します。
$m$が0でも1でもないとき$t=t_0+t_1$を成立させるように$c_1$たちを選ぶのは非常に困難です。

ここではlifted-ElGamal暗号で平文が0か1のどちらかであることのみを検証する方法を紹介しました。
クライアントが不正をしていないか確認するためにゼロ知識証明を使っています。
逆にクラウドに\ref{chap:homo}章のような準同型演算をさせるときは、クラウドが不正をしていないか検証したいです。
ある種の一般的な回路に対して正しく計算していることを検証できる枠組みを作る研究もあります~\cite{SNARK}。

\section{電子投票}
\label{vote}
この節では電子投票について考えてみます。
秘密投票を電子的に行うにはどうすればよいでしょうか。
\ref{blind_sig}節ではブラインド署名が電子投票に使われると書きました。
ここではブラインド署名を使わない方式を紹介しましょう。

Aさんの投票$m$を暗号化$\Enc(m)$しても、どこかのタイミングで復号しなければなりません。
復号する人が$\Enc(m)$がAさんの投票だとわかっていれば、その人はAさんがどういう投票をしたのかわかってしまいます。
したがって誰がどの暗号文を作ったのかわからないようにしなければなりません。

現実の期日前投票では秘密保持のために二重封筒を使います。
投票用紙を内封筒に入れて封をし、それを外封筒に入れて封をして署名します。
外封筒を開ける人は署名者が当人であること、当日に選挙権があることなどを確認します。
外封筒のみを開封して内封筒をとりだした状態で皆の封筒を混ぜます。
そうすると、どれが誰の封筒だったかわからなくなります。
そのあと内封筒を開封して集計します\footnote{「町田市 投票日に用事ができた」マメ知識「2重封筒のその後」:\\ \url{https://www.city.machida.tokyo.jp/shisei/senkyo/tohyo/tohyo03.html}}。

この操作と同様のことをするために皆の暗号文を集めてからかき混ぜる操作を行います。
これをミックスネット（Mix-net）といいます。
より安全にするためにミックスネットを複数回適用することも考えられます。

また復号鍵を複数個に分割し全てが揃わないと復号できないようにすることで開票者が一人で不正できないようにすることもできます。
\image{vote.pdf}{不在投票と電子投票}
ミックスネットに求められる性質を考えてみましょう。
まず、どの暗号文がどの人のものだったのか誰にもわからないようにかき混ぜなければなりません。
それからミックスネットが不正をしないようにしなければなりません。
誰かの投票を消して別の人の投票にしたりするとそれを第三者が検出できるようにします。
これはゼロ知識証明などを使って行います。

\section{シャッフル}
暗号文をかき混ぜる（シャッフルする）ときに使われる再暗号化という方法を紹介します。
ElGamal暗号にはちょっと面白い性質があります。
公開鍵$(g,y)$と乱数$r$を使って平文$m$を暗号化します。
\[
\Enc(m):=(c_1,c_2)=(g^r,my^r).
\]
この暗号文を受けた人が新たに乱数$r'$を使って$c_1$と$c_2$から
\[
(c_1',c_2'):=(g^{r'}c_1,y^{r'}c_2)
\]
を作ります。これは結局
\[
(c_1',c_2')=(g^{r+r'},my^{r+r'})
\]
となり乱数$r+r'$を使って$m$を暗号化したのと同じです。
元の平文を知らなくても他人が暗号化したものを暗号化し直すことができるのです。
あるいはElGamal暗号の乗法準同型性を用いて暗号文$\Enc(m)$に平文1の暗号文$\Enc(1)=(g^{r'},y^{r'})$を掛けた考えることもできます。
これをElGamal再暗号化といいます。再暗号化すると元の暗号文がなんだったかわからなくなります。
そうすると、与えられたElGamal暗号の暗号文$c_1$, ..., $c_n$に対してそれぞれを再暗号化してシャッフルすることでミックスネットを実現できます。

\section{シャッフルのゼロ知識証明}
ElGamal暗号でシャッフルを用いたミックスネットは第三者がゼロ知識証明を用いて不正をしていないかチェックすることができます。
2001年古川氏と佐古氏により提案されました~\cite{Furukawa:2001}。

シャッフルは数学的には置換と呼ばれています。$n$個の値の置換には$n$次正方行列$A$が対応します。
たとえば$(a,b,c,d)$を置換して$(d,c,a,b)$にする場合、
\[
A:=
\begin{pmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0
\end{pmatrix}
, \quad
\begin{pmatrix}
d \\ c \\ a \\ b
\end{pmatrix}
=
A
\begin{pmatrix}
a \\ b \\ c \\ d
\end{pmatrix}
\]
とできます。この行列$A$がこの置換に対応します。
置換行列$A$はどの成分も0か1であり、どの行、どの列でも1になる値は一つしかありません。

さて$(g,y)$を公開鍵とする$n$個のElGamal暗号文$(g_i,t_i)$が与えられたとします。
$n$次置換行列$A$と$n$個の乱数$r_1, \dots, r_n$を用いるとElGamal再暗号化してシャッフルする操作は
\[
(g'_i,t'_i):=\left(g^{r_i} \prod_{j=1}^n g_j^{a_{ji}}, y^{r_i} \prod_{j=1}^n t_j^{a_{ji}}\right)
\]
と表せます。$\prod$が出ていて一見仰々しいですが、$a_{ji}$は$j$が走ったとき1個を除いて全て0なのに注意してください。
一つ目の成分の式を取り出すと
\label{vote_eq}
\begin{equation}
g'_i=g^{r_i} \prod_{j=1}^n g_j^{a_{ji}}.
\end{equation}
です。
$\Set{y, g_i, t_i}$が与えられるとミックスネットは乱数$r_i$と置換行列$A$を使って$(g'_i,t'_i)$を計算して返します。
値を受け取った人は正しくシャッフルされていることを確認します。
つまりゼロ知識証明を使って$r_i$と$A$を教えてもらわずにシャッフルに使われた$A$が置換行列であることを確認するのです。
実際のプロトコルはとても複雑なのでキーアイデアを紹介します。

まずある行列$A=(a_{ij})$が置換行列になる必要十分条件は
\begin{align}
\label{perm1}
& \sum_{h=1}^n a_{hi}a_{hj}= \delta_{ij},\\
\label{perm2}
& \sum_{h=1}^n a_{hi}a_{hj}a_{hk} = \delta_{ijk}
\end{align}
です。ここで$\delta_{ij}$は$i=j$のときのみ1、それ以外は0、
$\delta_{ijk}$は$i=j=k$のときのみ1、それ以外は0を表す記号です。

置換行列が上記式を満たすことを示すのはそれほど難しくありません。
$i=j$のとき$a_{hi}a_{hj}=a_{hi}^2$。$A$の要素は0か1なので$a_{hi}^2=a_{hi}$。
$h$を動かしたとき1になるのは一つだけなので
\[
\sum_{h=1}^n a_{hi}=1.
\]
二つの異なる行において、1になる列の位置は異なるので$i \ne j$のとき$a_{hi}a_{hj}=0$。
よって式（\ref{perm1}）が示されます。
式（\ref{perm2}）や逆向きの証明はここでは省略します。

さてミックスネットを検証したい人は$\Set{c_j}$をランダムにとりミックスネットに送ります。
ミックスネットは
\begin{align}
\label{vote_proof1}
& s:=\sum_{j=1}^n r_j c_j,\\
\label{vote_proof2}
& s_i:=\sum_{j=1}^n a_{ij} c_j
\end{align}
を計算して返します。検証者は
\begin{align}
\label{vote_proof3}
& \sum_{i=1}^n s_i^2 = \sum_{j=1}^n c_j^2,\\
\label{vote_proof4}
& g^s \prod_{i=1}^n g_i^{s_i} = \prod_{i=1}^n {g'}_i^{c_i}
\end{align}
を確認します。
式（\ref{vote_proof4}）に式（\ref{vote_eq}）、式（\ref{vote_proof1}）、式（\ref{vote_proof2}）を代入すると成立することを確認できます。
式（\ref{vote_proof3}）に式（\ref{vote_proof2}）を代入して式変形すると
\begin{align*}
\sum_{i=1}^n s_i^2 - \sum_{j=1}^n c_j^2 &= \sum_{i=1}^n \left(\sum_{j=1}^n a_{ij} c_j\right)\left(\sum_{k=1}^n a_{ik} c_k\right) - \sum_{j,k} c_j c_k \delta_{jk}\\
& = \sum_{j,k} \left(\sum_{i} a_{ij}a_{ik} - \delta_{jk} \right)c_j c_k=0
\end{align*}
となります。最後の等号は式（\ref{perm1}）からしたがいます。
逆にこの等式を満たす行列があったとき
勝手な$c_i$に対してこの等式が成り立つためには無視できる確率を除いて
\[
\sum_{i} a_{ij}a_{ik} - \delta_{jk}=0
\]
でなければなりません。
同様に3乗の式
\[
\sum_{i=1}^n s_i^3 = \sum_{j=1}^n c_j^3
\]
を考えると二つ目の式（\ref{perm2}）を満たす必要があることが示されます。
したがって検証者が式（\ref{vote_proof3}）と式（\ref{vote_proof4}）の成立を確認することで$A$が置換行列であることを検証できます。
実際には$s$を直接使うと$a_{ij}$の情報が漏れるため$s$や$s_i$にランダムな要素を加えてプロトコルを構成します。
このように構成することで判定DH問題が困難ならミックスネットが不正をしていないことを確認できることが示されます。

まとめるとDDH仮定の元で検証可能なミックスネットを構築できました。
その後対称多項式を使ったより効率のよい方法も提案されています。

\section{この章のまとめ}
自分が知っていることだけを相手に示すことができるゼロ知識証明という概念を紹介しました。
ゼロ知識証明を用いると、あるDLPの答えを知っていることを相手に証明したり、暗号化された値の中身を見ずに値がある条件を満たしているかを確認したりできます。

ゼロ知識証明はクライアントやサーバが不正をしていないか確認する際にも有用な技術です。