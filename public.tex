\chapter{公開鍵暗号}
この章では、公開鍵暗号について紹介します。
公開鍵暗号は1970年代に初めて構成された比較的新しい種類の暗号です。

公開鍵暗号は、共通鍵暗号の秘密鍵をどうやって安全に受け渡しできるかという問題から生まれました。
現在では様々な公開鍵暗号が提案されています。
その中でElGamal暗号という公開鍵暗号を紹介します。
ElGamal暗号は、このテキストで紹介したい新しい暗号技術において様々な場面で形を変えて登場する重要な暗号です。
ElGamal暗号は有限体という枠組みの中で構成されるのでその用語の説明から始めます。

最後に公開鍵暗号を使って運用するために必要な取り決めについて軽く紹介します。

\section{鍵の共有}
安全な共通鍵暗号があったとしましょう。
ネットショッピングをする場合、通信はどのような経路を通って行われているか分かりません。
もしかしたら誰かが盗聴しているかもしれません。
商品名や買い物に使うクレジット番号などを第三者には知られたくないので暗号化して送りたいです。
それで共通鍵暗号の一つAESを使ってその番号を暗号化しました。
さて、AESの秘密鍵をどうやって先方に知らせましょう。
その秘密鍵を更に別の共通鍵暗号で暗号化して送る？
その暗号化に使った鍵はどうしましょう。

共通鍵暗号を使うだけではきりがありません。
別の手段が必要だと分かります。
盗聴者がいたとしても二人の間で盗聴者には分からないように秘密鍵を共有する仕組みです。
次節以降でその方法について説明しましょう。

\section{余りの世界}
二人の間で安全に秘密の数字（秘密鍵）を共有するには、余りの世界の計算が必要になります。
たとえば日付を無視した時刻の流れがそれになります。
1日を24時間制で表し、今19時とします。1時間後は20時です。
5時間後の24時になると0時に戻ります。
50時間後なら2日と2時間後なので21時になります。
つまり時刻は24で割った余りを考えています。
\begin{figure}[H]
  \centering
  \includegraphics{img/tokei.pdf}
  \caption{時刻と余り}
  \label{tokei}
\end{figure}
一般に整数$a$を整数$p(>0)$で割った余りを$a \bmod p$と書くことにします。
より正確に書くと$a = qp + r$ ($0 \leq r < p$)となるような整数$q$, $r$を選んだとき$r$を余りと定義します。
$a$が負のときでも余りは常に0以上$p$未満になるように選びます。
また$a$と$b$の差が$p$で割れるとき$a \equiv b \pmod p$と書きます。
例をあげましょう。
\begin{align*}
& (19 + 1) \bmod 24 = 20,\\
& (19 + 6) \bmod 24 = 1,\\
& 50 \equiv 2 \pmod {24},\\
& (-35) \bmod {24} = 13.
\end{align*}
最後の等式については$-35 = (-2) \times 24 + 13$だからです。

この余りの世界で足し算と引き算を考えてみましょう。
余りを足したもの（を$p$で割った余り）は足したものの余りです。
数式で書くと
\[
((a \bmod p) + (b \bmod p)) \bmod p = (a + b) \bmod p.
\]
たとえば15 + 20 = 35ですが、$15 \bmod 12 = 3$, $20 \bmod 12 = 8$,
$35 \bmod 12 = 11$で$(3 + 8) \bmod 12 = 11$が成り立っています。

引き算や掛け算でも同じことが成り立ちます。
\begin{align*}
& ((a \bmod p) + (b \bmod p)) \bmod p = (a + b) \bmod p,\\
& ((a \bmod p) - (b \bmod p)) \bmod p = (a - b) \bmod p,\\
& ((a \bmod p) \times (b \bmod p)) \bmod p = (a \times b) \bmod p.
\end{align*}
掛け算を繰り返すことで巾乗（べきじょう）の計算もできます。
このとき上記3番目の性質によって、掛け算を全てすませてから余りをとるのではなく、掛けている途中の値に対して余りを取っても構いません。
たとえば$2^{30} \bmod 13 = 1073741824 \bmod 13 = 12$ですが、1073741824を13で割るのはちょっと面倒です。
でも$2^1$, $2^2$の余りを順に計算しながらやると13で割る数はせいぜい2桁なので簡単です。
\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
$a$            & 0 & 1 & 2 & 3 &  4 & 5 &  6 &  7 & 8 & 9 & 10 & 11 & 12 & 13 & 14\\\hline
$2^a \bmod 13$ & 1 & 2 & 4 & 8 &  3 & 6 & 12 & 11 & 9 & 5 & 10 & 7 & 1 & 2 & 4\\\hline
\end{tabular}
\end{center}
2を12乗したら1になりました。
そこからは2, 4, 8, $\dots$と続き、12進むごとに元に戻ることを繰り返します。
ということは24乗しても1です。だから
\[
2^{30} = 2^{24+6} = (2^{12})^2 \times 2^6 \equiv 2^6 \equiv 12 \pmod {13}
\]
と計算できます。
これからじっくりと説明していきますが、巾乗することは比較的容易なのに対してその逆、何乗したらある値になるかを求めるのは難しいことが知られています。
その一方向性が暗号の肝となります。
\section{Diffie-Hellman鍵共有}
\label{seq:dh-sharing}
1976年、余りの世界での巾乗計算を使って秘密鍵を共有する方法が考えられました。
その方法を提案者の名をとってDiffie-Hellman（ディフィー・ヘルマン）鍵共有（DH鍵共有）といいます。

次の方法を使ってAさんとBさんの間で秘密の数字を共有します。
\begin{itemize}
\item[1.] 整数$g$, $p$を二人の間で決めて平文で共有する。
$g$, $p$の条件は後述します。
\item[2.] Aは秘密鍵（秘密の値）$a$を決め公開鍵$K_A := g^a \bmod p$を求めてBに渡す。
ここで「$:=$」は左辺を右辺で定義するという記号です。
\item[3.] Bは秘密鍵$b$を決め公開鍵$K_B := g^b \bmod p$を求めてAに渡す（以後 ${}\bmod p$を省略します）。
\item[4.] Aは$a$とBからもらった$K_B$を使って${K_B}^a = (g^b)^a$を求める。
\item[5.] Bは$b$とAからもらった$K_A$を使って${K_A}^b = (g^a)^b$を求める。
\end{itemize}
${K_B}^a=(g^b)^a=g^{ab}=(g^a)^b={K_A}^{b}$なのでAとBは同じ値を共有できました。
\begin{figure}[H]
  \centering
  \includegraphics{img/dh.pdf}
  \caption{DH鍵共有}
  \label{dh-sharing}
\end{figure}
\section{鍵共有のための仮定と条件}
AさんとBさんは同じ値$g^{ab}$を共有できましたが、これは安全な方法なのでしょうか。
AさんとBさんのやりとりを盗聴していた第三者（攻撃者）がいたとします。
その攻撃者は$g$, $p$, $K_A$, $K_B$の値を知りえます。
公開鍵$K_A$を知っているのだから$a$を求められそうです。
実際$g^1$, $g^2$, ..., $g^{p-1}$と順番に計算していけばどれかは$K_A$に等しくなります。
つまり、しらみ潰しに確認すれば求めることは可能です。
この問題を定式化すると次のようになります。

「$g$, $p$, $g^a \bmod p$が与えられたときに$a$を求めよ。」

これを離散対数問題（Discrete Logarithm Problem）、略してDLPといいます。
一般に実数$x$, $y$, $a > 0$について$y=a^x$を満たすとき$x=\log_a y$と書き、$x$を「$a$を底（てい）とする$y$の対数」とよぶのでした。
DLPの場合、$h=g^a$とすると$a$は$g$を底とする$h$の対数とみなせます。
そして$a$, $h$, $g$は整数なので離散的な値です。
それで離散対数問題と呼ばれているのです。

今のところ$g$, $p$が次の条件を満たしているときのDLPは現在のコンピュータは求められないと考えられています。
DLPを解くのに必要な計算量が大きすぎて現実的な時間で解けないのです。
\begin{itemize}
\item[1.] $p$は1024ビット以上の素数で、$p-1$の約数の中に$p$に近い大きさの素数$q$がある。
\item[2.] $g$は$i=1, \dots, q-1$に対して$g^i \not \equiv 1 \bmod{p}$となる値（このような$g$を生成元といいます）。
\end{itemize}
2より大きい素数$p$は奇数なので、条件1で一番よいのは$q:=(p-1)/2$が素数となるときです。
条件2の生成元$g$は2や5が使われることが多いです~\cite{RFC3526}。
このような$(p,q,g)$の組をこのテキストではDHパラメータと呼ぶことにします（一般的な用語ではありません）。
この条件については\ref{order_cyclic}節で再度触れます。

もしかしたら明日、誰かがDLPの効率のよい方法を発見し、その求め方を公開するかもしれません。
あるいは既に解読方法を発見したけれども世の中の通信を盗み見するためにその方法を隠している人がいるかもしれません。
そんな不安はありますが、現在はDLPはとても難しい問題と考えられています。

すると攻撃者は公開鍵$K_A$や$K_B$からは秘密鍵$a$と$b$を求められません。
つまり$g^{ab}$は分からないのです。
よって$g^{ab}$はAとBの二人だけしか知らない数字となり、安全に秘密の数字を共有できたことになります。

\section{CDH仮定}
前節ではDLPが難しいのでDH鍵共有は安全だと説明しました。
でもちょっと待ってください。
$K_A$, $K_B$から$a$, $b$を求められなくても何らかの方法で直接$g^{ab}$を計算できたりしないのでしょうか。
この問題を定式化すると次のようになります。

「$g$, $p$, $g^a \bmod p$, $g^b \bmod p$が与えられたときに$g^{ab} \bmod p$を求めよ。」

この問題をDH問題（DHP : DH Problem）といいます。
DLPとはちょっと違います。もしDLPが解けるならDH問題は解けます。
$g$, $g^a$, $g^b$が与えられたときに$g$と$g^a$からDLPにより$a$を求めて$g^b$を$a$乗すれば$g^{ab}$を求められるからです。
しかし逆にDH問題が解けるからといってDLPが解けるか否かはすぐには分かりません。
DH問題も十分難しいと考えられていますが、今のところ二つの問題の同値性は示されていないようです。
DH問題が難しいという仮定をCDH仮定（Computational DH）といいます。
単にDH仮定、あるいはDHA（AはAssumption）ともいいます。
したがってこの用語を使うとDH鍵共有はCDH仮定の元で安全といえます。

\section{DH鍵共有の注意点}
DH鍵共有はCDH仮定の元で安全に秘密の数値を共有できることが分かりました。
ここで安全というのは、二人がやりとりする経路を攻撃者が盗聴していたとしても
$g^{ab}$は二人だけしか知らないようにできるという意味です。
しかし、攻撃者が盗聴だけでなく改竄（かいざん）までしていた場合の安全性を保証しているわけではありません。
\begin{figure}[H]
  \centering
  \includegraphics{img/dh-ok.pdf}
  \caption{正常時のDH鍵共有}
  \label{dh-ok}
\end{figure}
正常時はAの公開鍵$K_A$がBに、Bの公開鍵$K_B$がAに正しく送信されています。
このときは安全に共有できます。
\begin{figure}[H]
  \centering
  \includegraphics{img/dh-ng.pdf}
  \caption{改竄時のDH鍵共有}
  \label{dh-ng}
\end{figure}
しかし、途中経路に通信内容を改竄できる攻撃者がいたとします。
攻撃者は適当な数$c$, $d$を決めてAから来た$K_A$を受け取り$g^c$をBに渡します。
そしてBからきた$K_B$を受け取り$g^d$をAに渡します。

Aは$K_B$（と思っているが実は$g^d$）を$a$乗し$g^{ad}$を共有された秘密の値と思い込みます。
同様にBは$K_A$の代わりに$g^c$を$b$乗し$g^{bc}$が共有された値と思い込んでいます。
Aは$g^{ad}$を鍵として共通鍵暗号を使い送信します。
攻撃者は$K_A$を$d$乗し$g^{ad}$を持っているので復号できて中身を見ることができます。
次に$K_B$の$c$乗である$g^{bc}$を使って中身を暗号化してBに送信します。
Bは$g^{bc}$を使って復号できるので盗聴されているとは想像できません。

このように通信の途中に入って改竄する攻撃を中間者攻撃（MITM : Man in the Middle）といいます。
中間者攻撃されると安全ではないため、$K_A$, $K_B$を改竄されずに正しく送信できたかを確認する機構が必要になります。
これはDH鍵共有に限らない難しい問題で、後で考察します。

\section{巾乗の計算}
DH鍵共有では$p$が1024ビット以上、つまり10進数で300桁以上という条件があると書きました。
具体的にはたとえば\\
\texttt{\\
17976931348623159077293051907890247336179769789423065727343008\\
11577326758055009631327084773224075360211201138798713933576587\\
89768814416622492847430639474124377767893424865485276302219601\\
24609411945308295208500576883815068234246288147391311054082723\\
7163350510684586298239947245938479716304835356329624224137859}\\
という数字です。かなり大きいですね。
$a$も同じような大きさです。
素朴な疑問ですが、$2^a \bmod p$って計算できるのでしょうか。
たとえば1回の掛け算を1ナノ秒（$=10^{-9}$秒）でできたとします。
これは最近のパソコンの数十倍速い速度です。
しかしそれでも$2^2$, $2^3$, ...をえんえんと$10^{300}$回計算していると$10^{-9}\times 10^{300}秒 = 3 \times 10^{283}$年かかってしまいます。
これではまったく使い物になりません。DH鍵共有は絵に描いた餅なのでしょうか。
大丈夫です。そんなことはなく、ずっと少ない掛け算の回数で巾乗を計算する方法があります。

具体例で考えてみましょう。
$2^{100} \bmod 10^8$を計算してみます。
素朴な方法では99回の掛け算が必要です。
でも$100 = 25 \times 2 \times 2$と分解すれば掛け算の回数を減らせることに気がつきます。
$2^{100} = (((2^{25})^2)^2$なので$2^{25}$を求めましょう。
$2^{25} = 2 \times 2^{24} = 2 \times (2^3)^8$と変形できます。
\begin{align*}
& 2^3 = 2 \times 2 \times 2 \equiv 8 \pmod{10^8},\\
& 2^6 = (2^3)^2 \equiv 64 \pmod{10^8},\\
& 2^{12} = (2^6)^2 \equiv 4096 \pmod{10^8},\\
& 2^{24} = (2^{12})^2 \equiv 1777216 \pmod{10^8},\\
& 2^{25} = 2^{24} \times 2 \equiv 3554432 \pmod{10^8},\\
& 2^{50} = (2^{25})^2 \equiv 6842624 \pmod{10^8},\\
& 2^{100} = (2^{50})^2 \equiv 3205376 \pmod{10^8}
\end{align*}
というわけで8回の掛け算で求められました。これなら手計算でもなんとかできます。
このように2乗を組み合わせると掛け算の回数を減らせます。

\section{バイナリ法}
\label{binary-method}
バイナリ法とは$g^a \bmod p$を高速に求める計算アルゴリズムの一つです。
先程は$a=100$を適当に分割して計算を工夫しました。
もう少し一般的に適用できる方法でやってみます。
まず100を相異なる2の巾の和で書きます。
\[
100 = 64 + 32 + 4.
\]
この分割の方法は100を2進数に変換すると簡単にできます。
2進数に変換するには100を0になるまで繰り返し2で割り、その時の余りを逆順に並べるとよいです。
\begin{align*}
& 100 / 2 = 50 余り 0,\\
& 50 / 2 = 25 余り 0,\\
& 25 / 2 = 12 余り 1,\\
& 12 / 2 = 6 余り 0,\\
& 6 / 2 = 3 余り 0,\\
& 3 / 2 = 1 余り 1,\\
& 1 / 2 = 0 余り 1.
\end{align*}
下から余りを並べると1, 1, 0, 0, 1, 0, 0です。
100 = $\texttt{0b1100100}$とかけます。
先頭の$\texttt{0b}$は2進数であることを示す記号です。
1がある部分の位置の2巾の和になっています。
\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|r|}
\hline
$i$              & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\hline
$2^i$ & $2^6=64$ & $2^5=32$ & $2^4=16$ & $2^3=8$ & $2^2=4$ & $2^1=2$ & $2^0=1$ \\\hline
100   & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\\hline
\end{tabular}
\end{center}
\[
100 = 2^6 + 2^5 + 2^2 = 64 + 32 + 4.
\]
次に$g=2$の2巾の値を順次求めます。
一つ前の値の2乗を繰り返して作ります。
\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|r|}
\hline
$a$              & 1 & 2 & 4 &  8 & 16 & 32 & 64 \\\hline
$2^a \bmod 10^8$ & 2 & 4 & 16 & 256 & 65536 & 94967296 & 9551616\\\hline
\end{tabular}
\end{center}
すると
\begin{align*}
& 2^{100} = 2^{64+32+4}=2^{64}\times 2^{32} \times 2^{4}\\
& \equiv 9551616 \times 94967296 \times 16\\
& \equiv 3205376 \pmod {10^8}
\end{align*}
と計算できます。
演算回数は2の巾を求めるのに6回、$2^{100}$を求めるのに3回の計9回です。
先ほどのやり方より少し回数は多いですが99回よりはずっと少なく求められました。

このやり方は容易に一般化できます。
$a$を2進数展開したときに長さ$n$だったとします。
まず$g$の2乗を繰り返して$g$, $g^2$, $g^4$, $g^8, \ldots, g^{2^n} \bmod{p}$を作ります。
そして$a$を2進数に変換したときの1となった場所の$g^{2^i} \bmod{p}$を掛けていけばよいのです。

掛け算回数は2巾の表を作るのに$n-1$回、2進数展開したときの1となっている場所は最大$n-1$個なので
合計最大$2(n-1)$回です。
$a$が10進数で300桁程度なら、$10^{300} \approx 2^{1024}$なので$n=1024$。
つまり高々2000回程度の掛け算で$g^a \bmod{p}$を求められます。

この方法を使えば巾乗を十分高速に求められます。
$p$の2進数展開したときの長さは$\log_2(p)$なのでこのアルゴリズムの計算量は$O(\log(p))$です。
というわけでDH鍵共有は現実的な時間で計算できるアルゴリズムだと分かりました。

\section{公開鍵暗号}
\label{public_enc}
共通鍵暗号は秘密鍵をどうやって渡すかが悩ましいのでした。
そこで暗号化する鍵と復号する鍵を分けたらうまくいくのではないかと考えられた（かどうかは知りませんが）方式が公開鍵暗号です。
公開鍵暗号は一般的に次のような枠組みとして定義されます。
\begin{itemize}
\item[1.] 全員で使うためのパラメータの初期設定をする。
\item[2.] ユーザそれぞれが誰にも教えない秘密鍵$K'$と、みなに教える公開鍵$K$とを作る。
\item[3.] Aさんに平文$m$を送りたいときはAさんの公開鍵$K_A$を使って暗号化する。\\
$c := \Enc(K_A,m)$.
\item[4.] Aさんは自分の秘密鍵$K'_A$を使って復号する。\\
$m := \Dec(K'_A,c)$.
\end{itemize}
公開鍵$K_A$を使って暗号化された暗号文は秘密鍵$K'_A$を知っている人（Aさん）しか復号できません。
しかし$K_A$を知っている人は誰でも$K_A$を使って暗号化できます。

ここで$\Enc$は確率的アルゴリズムでなければなりません。
確率的アルゴリズムとは同じ秘密鍵$K_A$と同じ平文$m$を使っても$\Enc(K_A,m)$は毎回異なる値になるものでした（\ref{sec:determin}参照）。

どうして$\Enc$は確率的アルゴリズムでないといけないのでしょうか。
なぜならたとえばAさんがyesかnoのどちらかを暗号化して暗号文$c$を作ったことがわかっているとします。
盗聴者は公開鍵$K_A$を使って$\Enc(K_A,\text{yes})$と$\Enc(K_A,\text{no})$を作れます。
すると$\Enc$がいつも同じ値を出力する決定的アルゴリズムだったら、作った暗号文のどちらが$c$に等しいかを確認することで平文を当てることができてしまいます。

このように暗号を解読しようとする人（これを攻撃者といいます）が自分の好きな平文に対してその暗号文を入手できる状況での攻撃を選択平文攻撃（CPA : Chosen Plaintext Attack）といいます。
共通鍵暗号を使う場合にCPAが可能な状況はそれほど多くはありません。
しかし、公開鍵暗号では常にCPAを想定しなければなりません。
そのため公開鍵暗号は少なくとも確率的アルゴリズムである必要があるのです。
なお、$\Dec$は決定的アルゴリズムでかまいません。

さて、これからDH鍵共有方式を変形して公開鍵暗号の一つElGamal暗号を作ります。
その前に準備として余りの世界をもう少し見てみましょう。

\section{余りの世界再び}
\label{field_inv}
余りの世界では足し算、引き算、掛け算、巾乗算ができました。
ある集合の要素に対して演算の結果がまたその集合に入っているときその演算は閉じているといいます。
つまり、余りの世界で足し算、引き算、掛け算は閉じています。
整数の世界でも足し算、引き算、掛け算は閉じています。

ところが整数の世界では割り算をすると結果が整数にならないときがあります。
たとえば5割る3の値$5/3$は整数ではありません。
つまり割り算は整数の世界で閉じていません。
それに対して有理数の世界では四則演算は閉じています。
分数（整数を含む）同士のそれらの演算の結果はまた分数になるからです。

余りの世界はどうでしょうか。
整数と同じ割り算ではやはり閉じていません。
しかし整数の世界と異なり、余りの世界にはうまい割り算を導入できます。
それを見ていきましょう。

一般に0以外の整数$x$に対して$1/x$を$x$の逆数といいました。
$1/x$は$x$を掛けて1になる値です。
\[
(1/x) \cdot x = 1.
\]
たとえば$p = 13$として
\[
2 \times 7 = 14 \equiv 1 \pmod {13}
\]
という式を眺めます。
2と7を掛けて1になっています。
それで余りの世界では2の逆数$1/2$は7であると考えることにします。
\[
1/2 \equiv 7 \pmod {13}.
\]
7の逆数が2であると考えてもよいです。
\[
1/7 \equiv 2 \pmod {13}.
\]
すると$5 / 2$を$5 \times (1/2) \equiv 5 \times 7 = 35 \equiv 9 \pmod {13}$と考えると割り算ができることになります。
実際$9 \times 2 = 18 \equiv 5 \pmod {13}$なので$9 \equiv 5 / 2 \pmod{13}$として問題無さそうです。
同様に他の数の逆数も見てみましょう。
\begin{center}
13で割った余りの世界の逆数\\
\begin{tabular}{|l|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
$x$   & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 &10 &11 &12\\\hline
$1/x$ & 1 & 7 & 9 &10 & 8 &11 & 2 & 5 & 3 & 4 & 6 &12\\\hline
\end{tabular}
\end{center}
0以外の$x$にそれぞれについて、掛けると1になる逆数$1/x$が見つかりました。
効率のよい逆数の求め方については\ref{calc_field_inv}節で扱います。
このように0以外の余りの逆数を余りの世界で作れました。
したがって余りの世界で任意の$x$, $y(y \ne 0)$に対して$x/y$を定義できます。
つまり、この方式の割り算を使うなら余りの世界は割り算で閉じています。
この余りの世界を$\FF_p$と書きます。
$\FF_p$は0から$p-1$までの値からなる数の集合で、その中で足し算、引き算、掛け算、上記方式の割り算（0を除く）ができます。
一般に四則演算ができる集合を体（たい）\index{たい@体}といいます。
$\FF_p$は有限個の集合の体なので有限体といいます。$p$を標数といいます。
無限個の集合の体としては先ほどの有理数全体の他に実数全体、複素数全体の集合などがあります。

さて、$p=13$の余りの世界は体となりましたが、いつでもそうなるとは限りません。
たとえば$p = 12$の余りの世界を考えます。
$2 \times 6 = 12 \equiv 0 \bmod {12}$となります。
0でない2個の値を掛けたら0になってしまいました。
つまり2や6の逆数は考えられないのです。
もしあったらこの式の両辺に$1/2$をかけると$6 \equiv 0 \cdot (1 / 2) = 0 \bmod {12}$となり、6も0ということになってしまいます。
他には3の逆数を見つけようと、1から11まで順に掛けると、
\[
3, 6, 9, 0, 3, 6, 9, 0, 3, 6, 9
\]
となり掛けて1になる数がありません。つまり3の逆数が存在しないのです。
12で割った余りの世界では割り算について閉じてないので有限体でもありません。

一般に$p$が素数でないと1でない2個の数$a$, $b$を使って$a \times b = p \equiv 0 \pmod {p}$とかけるので、$a$や$b$は逆数を持ちません。
つまり合成数の余りの世界は有限体になりません。
逆に$p$が素数のときは必ず有限体になることを示すことができます。
証明は後半の\ref{calc_field_inv}節で紹介します。

\section{ElGamal暗号}
\label{sec:ElGamal}
有限体$\FF_p$の説明をしたのでElGamal（エルガマル）暗号という公開鍵暗号を作れます。
これは1984年に提案されました。次のような方式です。

$g$と$p$を固定し、みなに公開します。
$x$をランダムに選び$y := g^x \bmod p$とします（以後mod $p$は省略します）。
$x$が秘密鍵で$y$が公開鍵です。

公開鍵$y$を公開している人に対して平文$m$を暗号化して送るには次のようにします。
整数$r$をランダムに選び暗号文
\[
\Enc(m) := (g^r, my^r)
\]
を計算して$\Enc(m)$を送ります。

暗号文$(c_1,c_2):=\Enc(m)$を受け取った人は秘密鍵$x$を用いて次のように復号します。
\[
\Dec(c_1, c_2) := c_2/c_1^x.
\]
ここで割り算は前節の有限体の中での割り算を表しています。
$m$を暗号化して復号すると
\[
c_1=g^r, \quad c_2=my^r
\]
により
\[
\Dec(\Enc(m))=\Dec(c_1,c_2)=c_2/c_1^x=my^r/(g^r)^x=mg^{rx}/g^{rx}=m
\]
となって乱数$r$が消えて元の$m$に戻ります。

ElGamal暗号はCDH仮定の元で秘密鍵を知らない人は復号できないことが知られています。
なお、暗号化するときに乱数$r$を使っているので同じ$m$を暗号化しても$\Enc(m)$は毎回異なる暗号文を出力します。
だからElGamal暗号は確率的アルゴリズムです。

\section{強秘匿性とDDH仮定}
\label{sec:ind}
公開鍵暗号の安全性についてもう少し考えてみましょう。
\ref{public_enc}節でも触れたようにAさんとBさんがやりとりするとき、Aさんが質問をしてBさんがyesかnoで答える状況はよくあります。
それを盗聴して暗号を解読しようとする攻撃者は、外部の状況からBさんがyesかnoのどちらかを答えたと推測していたとします。
攻撃者の立場からすると次の問題を考えることになります。

「2個の異なる平文$m$, $m'$およびこのどちらかを暗号した$c$が与えられたとする。
このときどちらの平文を暗号化したものか当てよ。」
\begin{figure}[H]
  \centering
  \includegraphics{img/ind-atk.pdf}
  \caption{当てっこ問題}
  \label{ind-atk}
\end{figure}
当てっこ問題の出題者、つまり暗号文を作る人を挑戦者といいます。
暗号が安全であるためには攻撃者が負けること、つまりこの当てっこ問題ができないことが望まれます。
できないというのは攻撃者がどんなにがんばったとしても、何も考えずに答えて当たる確率$1/2$と殆ど同じにしかできないという意味です。
このとき暗号文の情報は何も漏れていないと考えられます。
この性質を強秘匿性（きょうひとくせい）といいます。

ElGamal暗号で強秘匿性の条件を考えてみましょう。
$g$, $y:=g^x$で$a$を$a=m$か$a=m'$のどちらかとして$(c_1,c_2):=\Enc(a)=(g^r,ay^r)=(g^r,ag^{rx})$を受け取ります。
$z:=c_2/m$か$c_2/m'$のどちらかは$g^{rx}$になります。
CDH仮定から$g$, $g^x$, $g^r$から$g^{rx}$は求まりませんが、$z$が$g^{rx}$かどうかは判るのでしょうか。
答えを教えてもらっている可能性があるのだから攻撃者にとってかなり有利に思えます。
つまり、

「$g$, $g^a$, $g^b$が与えられ、更に$z_1:=g^{ab}$かランダムな$c$に対する$z_2:=g^c$のどちらかの$z_i$が与えられたとき$i$は1と2のどちらか判定せよ。」

これを判定DH問題(DDH : Decisional Diffie-Hellman)といい、今のところDDHも十分難しいと考えられています。
DDH仮定のもとでElGamal暗号は強秘匿性を持っています。
DLPが解ければCDHが解け、CDHが解けるならDDHが解けます。
つまりDLPが一番難しくて、次にCDH、DDHの順で易しくなります。

ちょっと混乱しやすいので別の例をあげると任意の3次方程式が解けるなら2次方程式が解け、2次方程式が解けるなら1次方程式が解けます。
一番難しい問題は3次方程式を解くことです。逆に「相手が解けない」ということを仮定するなら「1次方程式が解けない」という仮定が一番強い仮定です。
これは「3次方程式が解けない」という仮定を含むからです。

よってDLP仮定, CDH仮定, DDH仮定の中ではDDH仮定が一番強い仮定です。
これからいろいろな問題の困難さを仮定した暗号を紹介しますが、大抵は値そのものを求める計算問題と、それに対応した判定問題があります。

\section{ElGamal暗号の弱点}
\label{sec:ElGamal_weak}
ElGamal暗号はDDH仮定の元で強秘匿性を持つのでした。
秘密鍵を知らない人は全然平文の情報を得られないのだから絶対安全と思えます。
しかし、強秘匿性を持っていたとしても状況によっては必ずしも安全とは限らないのです。
第三者は復号できないけれどもメッセージの値を改変できるかもしれないからです。

たとえば秘密の通信をしている二人の間に攻撃者がいて$\Enc(m)=(c_1,c_2)$を盗聴し、
$(c_1, 10c_2)$と変更して相手に渡したと考えてみましょう。
すると受信者は$\Dec(c_1, 10c_2)=10my^r/g^{rx}=10m$と復号してしまいます。
\begin{figure}[H]
  \centering
  \includegraphics{img/elgamal-weak.pdf}
  \caption{ElGamal暗号に対する攻撃者による平文の改竄}
  \label{elgamal-weak}
\end{figure}
もともと$m$という値だったのが$10m$という値に変わりました。
もし$m$が商品の値段だったら10倍の値段になってしまったのです。
これでは困ります。平文が分からないだけでなく、その値を操作されてもいけないのです。
そのような変更ができないことを頑強性（がんきょうせい）とか非展性（ひてんせい）といいます。

\section{より強力な攻撃}
公開鍵暗号では、攻撃者はいつでも自分の好きな平文を選んで暗号化することで情報を得る攻撃 −選択平文攻撃（CPA）− ができました。
これに対して、選択暗号文攻撃（CCA : Chosen Ciphertext Attack）と呼ばれる攻撃があります。
攻撃者は平文ではなく暗号文を選びます。

まず攻撃者が暗号文$c$を攻撃する際、$c$とは異なる好きな暗号文を選んで攻撃対象者に渡します。
そして攻撃対象者に復号してもらい、その平文を取得します（これを問い合わせとよぶことにします）。
問い合わせで得た情報を元に$c$を解読する攻撃です。
「え、問い合わせなんてできないでしょ」という疑問は少し脇に置いてください。

CCAには2種類あります。
問い合わせが攻撃対象の暗号文$c$が与えられる前にしかできないものをCCA1といいます。
$c$が与えられてからも、それに応じた戦略を立てて問い合わせする攻撃を適応的選択暗号文攻撃CCA2といいます。
当然CPAよりもCCA1, CCA2の方が攻撃者の攻撃能力が強い状況です。
\ref{sec:ind}節の当てっこ問題でCCAを考えると図\ref{fig:cca}の様に点線で囲まれた部分が増えます。
\begin{figure}[H]
  \centering
  \includegraphics{img/ind-cca.pdf}
  \caption{CCA版当てっこ問題}
  \label{fig:cca}
\end{figure}
喩えるなら、CCA1は本試験の前に模擬試験の問題を考えて先生に答えを聞く状況です。
CCA2は本試験が始まってからも試験中にしつこく類題を出して先生に答えを聞いてから試験問題を考えている状況です。
CCA1はまだしもCCA2はかなりずるい？です。

こんな攻撃に対しても安全、つまりCCA版当てっこ問題が解けないときIND-CCA1, IND-CCA2安全といいます。
INDは識別不可能性（indistinguishability）を意味します。当てっこ問題でどちらか識別できないからです。
なお、\ref{sec:ElGamal_weak}節では暗号文を改竄されない頑強性も必要だと書きました。
ElGamal暗号はIND-CCA2安全ではありません。
なぜなら$c:=\Enc(m)$を攻撃するとき、問い合わせで対象暗号文$c$の2倍の値（これは$c$とは異なるので可能です）を渡して$m':=\Dec(2c)$の値をもらいます。
すると、それから$m'/2=m$を求めることで元の暗号文を復号できてしまうからです。

このように一般にIND-CCA2安全な暗号は頑強性を持っていなければならないことが示されます。
現在はIND-CCA2安全な公開鍵暗号が最も安全であると考えられています。
1998年、ElGamal暗号とハッシュ関数を組み合わせたCramer-Shoup暗号が提案されました。
Cramer-Shoup暗号はIND-CCA2安全で実用的な暗号の一つです。

当てっこ問題は専門的にはゲームと呼ばれます。
今まで「○○の問題が難しいという仮定の元で安全だと示される」という言い方をしていました。
これはより正確には、その対偶である「もしそのゲームに勝つ攻撃者がいたとすると、その問題の答えを見つけることができる」という形で示されます。
その厳密な証明手法は『公開鍵暗号の数理』（森山大輔、西巻陵、岡本龍明）~\cite{MNO}がとても詳しいです。

ところで実際のところこのような暗号文を復号してもらえるような状況は考えにくいです。
そのためCCAは主に理論的観点から研究されていました。
ところが1998年、BleichenbacherはCCAが現実的にありえる攻撃であることを示します~\cite{Bleichenbacher98chosenciphertext}。
次節で述べるRSA暗号の標準フォーマット（PKCS \#1）では平文にヘッダとパディング情報を付与して暗号化します。
盗聴者（攻撃者）が普通の通信のふりをして暗号文$c_i$を渡して攻撃対象者（挑戦者）に渡します。
挑戦者が復号しようとして、ヘッダがおかしかったのでエラーを出します。
そのエラー情報から平文の情報が少し漏れるのです。
つまり問い合わせをエラー情報で代用するのです。攻撃者はこれを数十万回繰り返すことで解読します。
\ref{POD}節で触れた攻撃と同様の手法ですね。
2012年、Romain, Riccardo, 川本氏, Lorenzo, Graham, Joe-Kaiたちは、この手法よりもずっと攻撃回数が少なくてすむパディングオラクル攻撃を提案します~\cite{BardouFKSST12}~\cite{padding_oracle}。
このため、現在ではCCAに対しても安全であることが望ましいです。
また暗号プロトコルを実装する際、復号時のエラーメッセージに詳しい情報を載せてはいけません。

\section{攻撃と安全性のまとめ}
公開鍵暗号に対する攻撃者のいろいろな攻撃や、暗号が持つべき安全性に関する性質がでてきました。
ここで少しまとめておきましょう。

暗号文が与えられたときに平文に戻せてはいけません。これは当然ですね。
暗号が持つべきこの性質を\textbf{一方向性}といいます。
それ以外にも次の性質を持つのが望ましいことを紹介しました。
\begin{itemize}
\item[] \textbf{強秘匿性}：暗号文からもとの平文のどんな情報もえられないこと。
\item[] \textbf{頑強性}：暗号文をいじって、もとの平文と関係のある別の暗号文を作れないこと。
\end{itemize}
一般に強秘匿性よりも頑強性を持つ暗号がより安全です。
たとえばElGamal暗号は強秘匿性を持ちましたが、頑強性は持ちませんでした。

それから公開鍵暗号の攻撃には攻撃者が持つ能力に応じていくつかの種類があります。
攻撃したい暗号文を$c$とします。
\begin{itemize}
\item[] \textbf{選択平文攻撃（CPA）}：暗号文$c$を受けとる前後に自分で選んだ平文に対応する暗号文を得られる。
\item[] \textbf{選択暗号文攻撃（CCA1）}：暗号文$c$を受け取る前に、自分で選んだ$c$以外の暗号文に対応する平文を得られる。
\item[] \textbf{適応的選択暗号文攻撃（CCA2）}：暗号文$c$を受け取る前後に、自分で選んだ$c$以外の暗号文に対応する平文を得られる。
\end{itemize}
公開鍵暗号では、攻撃者は公開鍵を使って自分で選んだ平文に対応する暗号文を作れるのでCPA安全であることは最低限の要件です。
後者になるほど攻撃者の能力は高いです。

CPA, CCA1, CCA2に対して強秘匿性を持つ暗号をIND-CPA安全、IND-CCA1安全、IND-CCA2安全といいます。
同様に頑強性に対してもこれらの攻撃に対して安全な性質を考えられます。
つまりCCA2に対して頑強性を持つ暗号が最も安全と考えられます。
ただCCA2に対して強秘匿性を持てば頑強性を持つことが知られています。
したがって強秘匿性を持つIND-CCA2安全な（つまり同時に頑強性も備える）公開鍵暗号が理想です。

\section{RSA暗号}
\label{rsa}
RSA暗号はElGamal暗号とは別の公開鍵暗号です。
1977年にRivest, Shamir, Adlemanたちにより初めて公開鍵暗号を実現したものとして広く知られています。
ただイギリスの通信電子セキュリティグループ（CESG）によると1970代初頭にCocksたちが彼らよりも先に公開鍵暗号の概念やRSA暗号などを考えていたそうです~\cite{Cocks}。

$p$, $q$を相異なる素数とし$n:=pq$とします。
整数$e$を選び
\[
de \equiv 1 \pmod{(p-1)(q-1)}
\]
となる整数$d$を求めます。
$(n,e)$が公開鍵で$d$が秘密鍵です。
RSA暗号は平文$m$に対して暗号文$c$を
\[
c=\Enc(m):=m^e \bmod{n}、
\]
で計算します。
復号は暗号文$c$に対して
\[
\Dec(c):=c^d \bmod{n}
\]
とします。
後半の\ref{fermat_inv}節で紹介する定理を使うと任意の整数$x$に対して$x^{p-1}-1$は$p$で割り切れ、
$x^{q-1}-1$は$q$で割り切れます。
つまり$m^{(p-1)(q-1)}-1=(m^{q-1})^{p-1}-1=(m^{p-1})^{q-1}-1$は$p$でも$q$でも割り切れます。
$p$と$q$は互いに素な素数なので$m^{(p-1)(q-1)}-1$は$n=pq$で割り切れます。
すなわち
\[
m^{(p-1)(q-1)} \equiv 1 \pmod{n}.
\]
$d$, $e$の作り方から、ある整数$s$が存在して
\[
de=1+s(p-1)(q-1).
\]
よって
\begin{align*}
\Dec(c)& \equiv c^d \equiv (m^e)^d= m^{de} = m^{1+s(p-1)(q-1)}\\
&=m \left(m^{(p-1)(q-1)}\right)^s \equiv m \pmod{n}
\end{align*}
となりRSA暗号は正しく復号できることが分かります。
$(n,e,c=m^e)$から$m$を求める問題をRSA問題といいます。
$n$が十分大きくていくつかの細かい条件を満たすとき、RSA問題は難しいと考えられています。
RSA問題が困難であるという仮定をRSA仮定といいます。

$n=pq$の$p$, $q$が求められれば$d$は容易に求めることができます。
RSA問題は$n$が与えられたときに$n$を素因数分解する問題とほぼ同等の難しさを持っていると考えられています。

RSA暗号のアルゴリズムには乱数が登場しないので決定的なアルゴリズムです。
したがってこのままでは安全な公開鍵暗号とはいえません。
また、$c_1=m_1^e$, $c_2=m_2^e$が与えられたとき$c_1 c_2 = (m_1 m_2)^e$が成り立つので復号しなくても$m_1 m_2$の暗号文を作ることができます。
ElGamal暗号と同じく頑強性も持っていません。

1994年、Bellare, Rogawayたちはある種の関数があると、いくつかの条件の元でIND-CCA2安全な暗号を作ることができる枠組みを提案します。
その枠組みはOAEP（Optimal asymmetric encryption padding）と呼ばれます~\cite{HOWTOENC}。
2001年、藤崎氏、岡本氏、Pointcheval, SternたちはOAEPが安全であることを正しく証明します~\cite{Fujisaki:2004}。
OAEPをRSA暗号に適用することでIND-CCA2安全な暗号RSA-OAEPを作れます。

\section{公開鍵基盤と認証局}
さて、現在最も強力なIND-CCA2安全な公開鍵暗号があればもう何も問題なく安心して秘密に通信できるのでしょうか。
残念ながらそうとは限らないので困ってしまいます。

AさんがBさんと公開鍵暗号を使って通信するとします。
AにとってBの公開鍵は本当にBのものなのでしょうか。
AがBとは知り合いで普段からメールやwebなどでやりとりをしていて、そのときB自身が常に自分の公開鍵をそれらに添付していればほぼ本人のものと考えて問題ないでしょう。
実際に会って公開鍵を手渡しすると確実です。
BにとってのAも同様です。

しかしBがショップの運営者で、Aは初めてBと通信をするときを考えます。
AはBの公開鍵を持っていないのでAはBからBの公開鍵をもらわなければなりません。
もし、その通信路がDH鍵共有のところで述べた中間者攻撃を受けているとその公開鍵を使った通信は安全になりません。
つまりAがBの公開鍵をもらうところで何か安心できる方法が必要になります。

公開鍵が正しいことや、通信経路で改竄されていないことを検証するには\ref{authentication}章で説明するメッセージ認証符号（MAC）やデジタル署名を使います。
しかしデジタル署名には公開鍵が必要です。
その公開鍵はどうやって送るのでしょう。
またもや元に戻ってしまいました。互いが互いを必要としていて循環しています。
\begin{figure}[H]
  \centering
  \includegraphics{img/pki.pdf}
  \caption{公開鍵とデジタル署名と認証局}
  \label{pki}
\end{figure}
インターネット上のBのサイトが本当にそのBのものなのかは暗号技術では知りようがありません。
Bの公開鍵が本当にBのものであると証明するものを公開鍵証明書といいます。
一般的には国際電気通信連合（ITU : International Telecommunication Union）が定めたX.509という規格が使われます。

公開鍵証明書の発行や失効の手続きをするところを認証局（CA : Certificate Authority）といいます。
認証局にはたとえばVeriSignを買収したSymantecやGlobalSignがあります。

認証局によって証明書を扱う枠組みが公開鍵基盤（PKI : Public Key Infrastructure）です。
PKIでは、信用できる認証局が保証している認証局は信用できるという形で信用の輪を広げます。

Bが認証局Xに証明書の発行依頼をすると、認証局XはBの身元確認をしてBの公開鍵証明書（エンドエンティティ証明書とかサーバ証明書といいます）を作成します。
Bのサーバ証明書は認証局Xの公開鍵でその正しさが検証されます。
認証局Xの証明書（CA証明書）は別の認証局Yの公開鍵で検証されます…と連鎖が続きます。

最終的に証明書の検証を自分自身の公開鍵で行うものにたどり着きます。
その証明書をルート証明書、その証明書を持つ認証局をルート認証局といいます。
ルート証明書はその認証局のブランドや実績によって信頼されます。
暗号的には無条件に受け入れるので非常に重要です。
いくつかのルート証明書はブラウザに最初から入っています。
私たちがブラウザで安心して公開鍵暗号を使えるのは、初めて行くサイトでもこの枠組みによってきちんと検証されているからです。

ブラウザに必要なルート証明書が含まれていないとサーバ証明書の検証が正しく行えず、警告が出ることがあります。
たとえば2015年3月の時点でFirefoxというブラウザで、総務省が管理する政府認証基盤（GPKI）のサイト\texttt{https://www.gpki.go.jp/}に接続すると「接続の安全性が確認できない」と表示されました。
こういった場合『自己署名証明書をダウンロードして「信頼する」にチェックしてください』と指定されることがありますが、不用意にOKと押すのはよくありません。

なぜならそういう証明書をhttp経由で取得した場合、通信経路は暗号化されず平文のままです。
そのためその証明書が改竄されていないことを検証できず、本物である保証を得られないからです。
振り込め詐欺の電話で「おれは本物だから安心してね」と言われて信用するのと変わらないことを理解してください。
オレオレ詐欺に掛けて「オレオレ証明書」と呼ばれることがあります。

証明書にはfingerprint（フィンガープリント：拇印）という印がついています。
そのfingerprintが指定されたものと同一であれば、証明書が改竄されていないことが保証されます。
もちろんそのfingerprintは同じサイトからとってきてはいけません（それも改竄されているかもしれない！）。
別の正しいと信じられるサイトを見るか、上記GPKIの証明書のfingerprintなら官報でも確認できます。

最後に無効化の話をします。
サーバ証明書が不要になれば認証局に無効化の依頼をします。
すると認証局はその証明書を失効し、失効リスト（CRL : Certificate Revocation List）と呼ばれる失効した証明書一覧に登録します。
実はブラウザが証明書を検証するときは証明書自体の検証の他に、最新のCRLを取得して証明書が失効されていないことを確認しています。
そうしないと失効した証明書を受け入れてしまう危険性があるからです。

このように公開鍵の正しさの確認には面倒な問題がつきまといます。
PKIによる正しさを維持する運営が必要不可欠です。

\section{PKIへの攻撃}
PKIにおける認証局の証明書は重要な役割を果たします。
ですから、そこを攻撃されると大きな被害が出ます。

2011年COMODOやDigiNotarという認証局への攻撃があり、認証局が偽のサーバ証明書を発行してしまう事件がありました。
DigiNotarは信頼を失い自身のルート証明書を無効化され、最終的に自己破産しました。
	\ignore{
1999年に512ビットRSA暗号が解読され、安全ではなくなりました。
それにもかかわらず512ビットRSA暗号を使った鍵を発行し、かつそれを失効できないような扱いをしてしまって問題になったことがあります。
}

2012年Flameというマルウェアは偽物のMicrosoftのWindows Updateを本物に見せかける証明書を作って攻撃をしました。
証明書の検証にMD5という安全ではないハッシュ関数を使っていたのが原因の一つです~\cite{Flame}。

2015年Lenovo製のパソコンの一部にプレインストールされていたSuperfishというソフトウェアの問題点が明らかになりました。
Superfishはブラウザで見ているサイトに広告を挿入するためのものです。
そのために独自の証明書を正しいルート証明書としてシステムに認識させていました。
つまり中間者攻撃と同じ原理で動作していたのです。
しかも独自の証明書の公開鍵と秘密鍵は全てのパソコンで同一でプログラムに埋め込まれていました。
そのため秘密鍵を知っている第三者はそのパソコンにとって正規の証明書と区別のつかない証明書を容易に作れます。
購入したパソコンが最初からそのような状態になっているとユーザは防御しようがなく、PKIの信頼性を根本から損なわせるものです。
同時に現在のPKIが「何かを信用する」ということの上に成り立っている技術だということを再認識させられます。

\section{この章のまとめ}
整数を素数で割った余りの世界を有限体といいます。
有限体では普通の足し算、引き算、掛け算の他に割り算も定義できます。
有限体上で巾乗の計算は易しいです。
しかしその逆、何乗したらその値になるかを求めること（離散対数問題）は難しいです。
暗号にとってこの一方向性が非常に重要な性質です。

離散対数問題が難しいという性質を用いてDH鍵共有やElGamal暗号という公開鍵暗号を作ります。
これにより二者間で秘密に通信できます。
公開鍵暗号の安全性にはいくつか段階がありIND-CCA2安全なものが一番よいとされています。

公開鍵暗号はその公開鍵が本人のものであることを別の手段で示す必要があり、現在は公開鍵基盤（PKI）を用いて検証されています。
公開鍵を安全に使うためにはPKIの絶え間ない維持が必要です。
