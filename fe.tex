\chapter{関数型暗号}
\label{chap:fe}

属性ベース暗号はポリシーと属性がマッチしたときに復号できる仕組みでした。
ポリシーと属性、およびマッチするということをより一般的な枠組みで考えようという動きがでます。
また応用によっては属性自体を隠したいこともあります。
述語暗号、関数型暗号と呼ばれる暗号で、これはIDベース暗号や属性ベース暗号の更なる拡張になっています。

\section{述語暗号}
2007年Katz, Sahai, Watersたちは属性ベース暗号を拡張した述語暗号（Predicate Encryption）を提案します~\cite{Katz:2008}。
後述の関数型暗号と呼ばれることもあります。
秘密鍵をあるパラメータ$v$を用いて作成し、暗号文は別のあるパラメータ$x$を用いて作成します。
そして$v$と$x$がある関係式$R(\cdot,\cdot)$を満たすときのみ復号できるという考え方です。
$R(\cdot,\cdot)$はパラメータ$v$, $x$を与えたときにtrueかfalseが決まり、trueのときは$v$と$x$は関係があるとみなします。

もう少し正確に言うと次の形です。
まず全体をつかさどるシステムはマスター秘密鍵$K_{\tt{prv}}$と公開鍵$K_{\tt{pub}}$を用意します。
それからシステムはパラメータ$v$にしたがって決まる秘密鍵$k_v$を作ります。
\[
k_v:=\KGen(K_{\tt{prv}},K_{\tt{pub}},v).
\]
ユーザは平文$m$を公開鍵$K_{\tt{pub}}$と別のあるパラメータ$x$を使って暗号化します。
\[
c_x:=\Enc(K_{\tt{pub}}, x, m).
\]
復号できるのは$R(v,x)$がtrueになる秘密鍵$k_v$を持っている人だけであり、
そのとき
\[
m=\Dec(K_{\tt{pub}}, k_v, c_x)
\]
と復号できます。

従来の属性ベース暗号では平文$m$を暗号化するときに指定した属性パラメータ$x$は誰でも知ることができました。
述語暗号ではどんなパラメータ$x$を使ったか暗号文を見てもわからないことが求められます。
たとえばある暗号文に「社内秘」、「極秘」といった属性がつけられていることを知られないようにできます。
属性を隠すのでそれを強調したいときはattribute-hidingあるいはprivate-indexといいます。
対応して従来の属性ベース暗号はpayload-hidingあるいはpublic-indexといわれます。

それからただ単に「関係がある」というのはちょっと一般的すぎます。
彼らの論文では2個のパラメータ$v$と$x$をベクトルとし、その2個のベクトルが直交するときに$v$と$x$は関係があるとして暗号を構成しました。
直交する条件は内積を用いて確認できるので内積暗号（IPE : Inner Product Encryption）ともいわれます。
内積というのは2個の$n$次元ベクトル$v:=(v_1, \dots, v_n)$, $x:=(x_1, \dots, x_n)$があったときに
\[
v\cdot x := \sum_{i=1}^n v_i x_i
\]
で定義される値のことです。
2個のベクトル$v$, $x$が直交するときのみ内積は0になり、そのとき関係があるとするのです。
\[
R(v, x) :=
\begin{cases}
\text{true if } v \cdot x = 0,\\
\text{false if } v \cdot x \ne 0.
\end{cases}
\]
$n=2$のとき図\ref{fig:inner-product.pdf}を見ながら内積の意味を確認しておきましょう。
\image{inner-product.pdf}{直交する2次元ベクトル}
2個の2次元ベクトルを$x:=(a,b)$, $y:=(c,d)$とします。
点$(a, b)$を、原点を中心に90度半時計周りに回すと$(-b,a)$になります。
$(a,b)$と$(c,d)$が直角なら$(-b,a)$と$(c,d)$は並行です。よって
\[
\frac{-b}{a}=\frac{c}{d}.
\]
すなわち
\[
ac+bd=0.
\]
よって
\[
(a,b) \cdot (c,d) := ac+bd = 0
\]
です。より高い次元でも同様になります。

たとえば$v:=(1,a)$, $x:=(b,-1)$という2個の2次元パラメータを持つ内積暗号を考えます。
この内積暗号が復号できるのは$v \cdot x=b-a=0$、つまり$a=b$のときのみです。
パラメータ$a$に対してユーザに秘密鍵を渡し、ユーザはパラメータ$b$を使って暗号文を作ります。
復号できるのが$a=b$のときのみということなのですから$a$をIDと思うと、これはIDベース暗号を意味します。
つまり内積暗号はIDベース暗号の拡張になっています。

また3個のパラメータ$t$, $a$, $b$を用いて
\begin{align*}
&v:=(1, t, t^2),\\
&x:=(ab, -(a+b), 1)
\end{align*}
という2個の3次元ベクトルを考えます。この内積は
\[
v \cdot x=ab -(a+b)t + t^2 = (t-a)(t-b)
\]
となります。内積が0になるのは$t=a$または$t=b$のときです。
つまりこれは属性$t$が$a$または$b$のとき復号できるというポリシーを表します。
属性ベース暗号と考えることもできますね。

もう一つ、今「または」という条件を実現できることが確認できました。
次のようにすると「かつ」もできます。
4個のパラメータ$s$, $t$, $a$, $b$と乱数$r$, $r'$を用いて
\begin{align*}
&v:=(1, s, t),\\
&x:=(-ar-br', r, r')
\end{align*}
という2個の3次元ベクトルを考えます。この内積は
\[
v \cdot x = -ar-br'+sr+tr'=r(s-a)+r'(t-b)
\]
となります。$r$, $r'$は乱数なのでこの内積が0になるのは無視できる確率を除いて
$s=a$かつ$t=b$のときとなります。
より一般に$d$次多項式$f(t)$を2個の$d+1$次元ベクトルを用いて
\[
f(t):=\sum_{i=0}^d f_i t^i = (f_0, f_1, \dots, f_d) \cdot (1, t, t^2, \dots, t^d)
\]
と表現することでまざまな条件を内積が0という条件に埋め込めます。

Katzたちは内積暗号を合成数位数ペアリングと呼ばれるものを用いて構成しました。
合成数位数のペアリングは今まで紹介していた素数位数のペアリングに比べて10〜100倍遅いため~\cite{compsite_prime}、素数位数のペアリングを用いた手法が望まれます。
2010年、岡本氏、高島氏は素数位数のペアリングを用いて効率がよく、安全性の高い述語暗号を構成します~\cite{OT2010}。
更に条件の否定を、ある属性集合内でのnotという日常的な感覚にあった形で扱えます。
この方式は複数の楕円曲線上の点をまとめて扱う双線形写像ベクトル空間（DPVS : Dual Pairing Vector Space）を用いています。
DVPSについては次節で紹介しましょう。

理論的な進展としては2014年にGarg, Gentry, Halevi, Zhandryたちが一般の回路を条件に利用できる適応的安全な属性ベース暗号を提案します~\cite{GGHZ14a}。
これは\ref{tdh}節で少し触れた多重線形写像を前提として構成しています。
今のところ多重線形写像自体が実用的と呼べるものではありませんが興味深いところです。

\section{ベクトルの基底変換と内積}
DPVSの紹介の前に線形代数の基本をおさらいします。
$x$, $y$を有限体$\FF_p$の$n$個の点からなる横ベクトルとします。
\begin{align*}
&x:=(x_1, \dots, x_n) \in {\FF_p}^n,\\
&y:=(y_1, \dots, y_n) \in {\FF_p}^n.
\end{align*}
$B:=(b_{ij})$を行列式が0でない$n$次正方行列とし、
$b_i:=(b_{i1}, \dots, b_{in})$とすると$\bolB:=\Set{b_i}$は$V$の基底となり
$x_\bolB:=xB^{-1}:=(x'_1, \dots, x'_n)$は$\Set{b_i}$に関する$x$の表現ベクトルです。
すなわち
\[
x=xB^{-1} B = x_\bolB B=\sum_{i=1}^n x'_i b_i.
\]
同様に$C:=(B^T)^{-1}=(c_{ij})$（$B^T$で$B$の転置を表す）として、
\[
b^*_i:=(c_{i1}, \dots, c_{in})
\]
とすると$\bolB^*:=\Set{b^*_i}$も$V$の基底となり
$y_{\bolB^*}:=yB^T$は$\Set{b^*_i}$に関する$y$の表現ベクトルです。

$x$と$y$の内積を考えると
\[
x \cdot y = x y^T=(xB^{-1}) (B  y^T)=(xB^{-1})(y B^T)^T = x_\bolB \cdot y_{\bolB^*}.
\]
これは$x$と$y$の内積は$x$の$\bolB$に関する表現ベクトル$x_\bolB$と$y$の$\bolB^*$に関する表現ベクトル$y_{\bolB^*}$の内積に等しいことを意味しています。

具体例で考えると難しいことはしていません。
\[
x:=(1, 4), \quad y:=(2, 3), \quad B:=\matt{2}{3}{3}{5}, \quad B^{-1}=\matt{5}{-3}{-3}{2}
\]
とします。$b_1:=(2, 3)$, $b_2:=(3,5)$となり$x$を$b_1$, $b_2$の線形和で表すと
\[
x=(xB^{-1})B=(-7, 5)\vvec{b_1}{b_2}=-7b_1 + 5b_2.
\]
同様に$b_1^*:=(5, -3)$, $b_2^*:=(-3,2)$となり$y$を$b_1^*$, $b_2^*$の線形和で表すと
\[
y=(yB^T)((B^T)^{-1})=(13, 21)\vvec{b^*_1}{b^*_2}=13b^*_1+21b^*_2.
\]
内積は
\[
x \cdot y = (1, 4) \cdot (2, 3) = 1 \cdot 2 + 4 \cdot 3 = 14 = -7 \cdot 13 + 5 \cdot 21 = (-7, 5) \cdot (13, 21)
\]
が成立することを確認できます。

\section{DPVS}
さて$G$を素数$p$個の楕円曲線上の点からなる巡回群、その生成元を$P$、
$V$を$G$の$n$個の点からなる集合とします。
\[
V:=\underbrace{G \times \dots \times G}_{n個}.
\]
$V$の点の加算や$\FF_q$倍を各要素に対する操作として定義することで$V$は$\FF_q$-ベクトル空間になります。
$V$の$n$個の点$a_i$を
\[
a_i:=(0, \dots, \overset{i番目}{\check{P}}, \dots, 0)
\]
と定義します。
そうすると$V$の任意の点$x$は$\FF_q$の元$x_i$を用いて
\[
x=(x_1 P, \dots, x_n P) = (x_1 P,0, \dots, 0) + (0, x_2 P,0, \dots, 0) + \cdots = \sum_{i=1}^n x_i a_i
\]
と一意に表せます。よって$\bolA:=\Set{a_1, \dots, a_n}$は$V$の基底です。
この係数$x_i$を並べたものを基底$\bolA$に関する$x$の表現ベクトル
\[
x_{\bolA}:=(x_1, \dots, x_n) \in \FF_q^n
\]
と書くことにします。特に$a_i$の表現ベクトルは
\[
{a_i}_{\bolA}=(0, \dots, \overset{i番目}{\check{1}}, \dots, 0)
\]
です。
$V$の2点$x=(x_1 P, \dots, x_n P)$, $y=(y_1 P, \dots, y_n P)$に対して$V \times V$上のペアリングを
\[
e(x, y):= \prod_{i=1}^n e(x_i P,y_i P)
\]
と定義します。
右辺のペアリングは従来のペアリング$e:G \times G \rightarrow G_T$（$G_T$は位数$p$の巡回群）です。
すると
\[
e(x,y)=\prod_{i=1}^n e(P,P)^{x_i y_i}=e(P,P)^{\sum_{i=1}^n x_i y_i}=e(P,P)^{x_\bolA \cdot y_\bolA}
\]
となります。
右辺の$x_\bolA \cdot y_\bolA$は$x_\bolA$と$y_\bolA$の内積です。
$(p, V, G_T, \bolA, e)$の組をDPVSといいます。

基底の変換を考えましょう。
行列式が0でない$n$次正方行列$B=(b_{ij})$に対して
\[
b_i:=(b_{i1}P, \dots, b_{in}P) \in V
\]
とすると$\bolB:=\Set{b_i}$は$V$の基底です。
$C:=(B^T)^{-1}=(c_{ij})$として、
\[
b^*_i:=(c_{i1}P, \dots, c_{in}P) \in V
\]
とすると$\bolB^*:=\Set{b^*_i}$も$V$の基底になります。
$b_i$と$b^*_j$についてペアリングをとると、
\[
e(b_i,b^*_j)=\prod_{k=1}^n e(b_{ik}P, c_{jk}P)=e(P,P)^{\sum_{k=1}^n b_{ik} c_{jk}}.
\]
指数部分を見ると、$C=(B^T)^{-1}$より
\[
\sum_{k=1}^n b_{ik} c_{jk}=(BC^T)_{ij}=(B B^{^1})_{ij}=(I_n)_{ij}=
\begin{cases}
1 & \text{ if } i = j,\\
0 & \text{ if } i \neq j.
\end{cases}
\]
したがって
\[
e(b_i,b^*_j)=\delta_{ij}.
\]
よって$x, y \in V$について、
\[
e(x, y)=e(P,P)^{x_\bolA \cdot y_\bolA}=e(P,P)^{x_\bolB \cdot y_{\bolB^*}}
\]
が成立します。基底を取り替えてもその表現ベクトルの内積が変わらないためペアリングの値は同じです。

\section{DPVSを用いた内積暗号}
\label{dpvs}
DPVSを用いて構成したattribute-hidingな内積暗号を紹介します~\cite{OT2012}。
\mydescription{
\item[セットアップ] 自然数$n$と$4n+2$次元の行列$B$を決める。
乱数$r \in \FF_p$をとり、$C:=r(B^T)^{-1}$に対して$\bolB^*$を作る。
$C$は$r$倍されていますが、直交性などの性質は変わりません。
$g_T:=e(P,P)^r$とする。
行列$\bolB$と$g_T$がシステムの公開鍵で$\bolB^*$がシステムの秘密鍵である。
\item[鍵生成]
秘密鍵に付随するパラメータ$v \in {\FF_p}^n$に対する鍵生成を次のようにする。
$\sigma$, $\eta$を$\FF_q$, ${\FF_q}^n$からランダムに選び、秘密鍵$k^*$を
\[
k^*:=(\underbrace{1}_{1}, \underbrace{\sigma v}_{n}, \underbrace{0}_{2n}, \underbrace{\eta}_{n}, \underbrace{0}_{1})_{\bolB^*} \text{ に対応する$V$の元}
\]
としてユーザに渡す（基底$\bolB^*$を用いて計算する）。
ここで1, $n$, $2n$, $n$, 1はそれぞれの次元を表す。
\item[暗号化]
平文$m$とパラメータ$x \in {\FF_p}^n$に対する暗号化は、
$\omega$, $\phi$, $\zeta$をランダムに選び、
\begin{align*}
&c_1:=(\underbrace{\zeta}_{1},\underbrace{\omega x}_{n},\underbrace{0}_{2n}, \underbrace{0}_{n},\underbrace{\phi}_{1})_\bolB \text{ に対応する$V$の元},\\
&c_2:=g_T^\zeta m,\\
&\Enc(m, x):=(c_1,c_2)
\end{align*}
とする。
\item[復号]
暗号文$(c_1,c_2):=\Enc(m,x)$に対して
\[
\Dec(c_1,c_2):=c_2/e(c_1,k^*)
\]
で復号する。
}
$e(c_1,k^*)$の指数部分は$c_1$, $k^*$のベクトル表現の内積に等しいのでした。
\[
e(c_1,k^*)=g_T^{(\zeta,\omega x, 0, 0, \phi) \cdot (1, \sigma v, 0, \eta, 0)}=g_T^{\zeta + \omega \sigma v \cdot x}.
\]
$v \cdot x = 0$が成立するなら
\[
c_2/e(c_1,k^*)=g_T^\zeta m / g_T^{\zeta}=m
\]
より復号できます。

基底の変換はベクトルを隠すために使われます。
たとえば$xyz$-3次元空間の中であるベクトル$v=(a,b,c)$が$xy$平面にあるかどうかは$z$成分$c$が0かそうでないかですぐわかります。
では適当な基底$b_1$, $b_2$, $b_3$をとったときに$v$が$b_1$と$b_2$で作られる平面の中にあるかどうかという問題はどうでしょう。
\ref{dlin}節で紹介するDLIN仮定のもとでは、この問題は難しいことが知られています。

一見$k^*$や$c_1$の最初の成分$(1,\sigma v)$や$(\zeta,\omega x)$の後半部分は不要に見えます。
しかし$3n+1$だけ余計につけることでこの方式がDLIN仮定のもとで適応的安全であり、パラメータ$x$の情報をもらさないattribute-hidingな方式であることが証明されます。
$k^*$や$c_1$は$4n+2$次元全体ではなくその部分空間を動くのですが、DLIN仮定のもとではランダムに選んだ点と区別できないということを非常に複雑な手順で証明しています。

\section{関数型暗号}
述語暗号はもう少しだけ一般化されます。
それは復号すると元の平文ではなく、指定した関数に平文を入れた値が出てくるというものです。
述語暗号と同様に定式化すると次のようになります。
まず2個のパラメータ$v$と$X$にしたがって決まる関数$f$を決めます。
全体をつかさどるシステムはマスター秘密鍵$K_{\tt{prv}}$と公開鍵$K_{\tt{pub}}$を用意します。
それからシステムはパラメータ$v$にしたがって決まる秘密鍵$k_v$を作ります。
\[
k_v:=\KGen(K_{\tt{prv}},K_{\tt{pub}},v).
\]
ユーザは平文$X$を公開鍵$K_{\tt{pub}}$を使って暗号化します。
\[
c_X:=\Enc(K_{\tt{pub}}, X).
\]
そのとき
\[
\Dec(K_{\tt{pub}}, k_v, c_X)=f(v,X)
\]
となります。$X$がそのままでるのではなく計算された結果がでるのです。
このような形の暗号を関数型暗号（FE : Functional Encryption）といいます。
$X$をパラメータ$x$と従来の平文$m$の組$X:=(x,m)$とし、
\[
f(v,(x,m)):=
\begin{cases}
m & \text{ if } R(v,x)=\text{true},\\
\text{出力しない} & \text{ if } R(v,x)=\text{false}
\end{cases}
\]
とすると関係$R(\cdot,\cdot)$に関する述語暗号となるので関数型暗号は述語暗号の一般化です。
ただどんな関数$f$が使えるとなると一般論の構成はとても難しいことが想像できます。

識別不能難読化(iO)と呼ばれる手法を用いた一般的な構成法が提案されていますが~\cite{waters:fe}、一般的すぎて効率のことは考えられていません。この分野は今しばらく理論面を進める動きが強いようです。

\section{この章のまとめ}
属性ベース暗号をより一般化した述語暗号や関数型暗号を紹介しました。
これらの暗号は秘密鍵と公開鍵の他に様々なパラメータを持ち、それらのパラメータにある関係があるときのみ復号できる暗号です。
述語暗号では暗号化に使われたパラメータを秘密にできます。
