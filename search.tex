\chapter{検索可能暗号}
\label{chap:search}
クラウドサービスの発展に伴ってデータを外部のサーバに預ける機会が増えています。
重要なデータは万一のデータ漏洩に備えて手元で暗号化してからサーバに置きたいものです。
そうすると安全性は高まりますが、データを暗号化したままサーバにそれらの処理をさせる仕組みが望まれます。
この章では暗号化したまま検索を行う方法を紹介しましょう。

\section{キーワード検索}
いきなり任意の検索ができるものを考えるのは難しいのでまずキーワード検索から始めます。
ここでキーワード検索とは、各文章データに対して予めいくつかのキーワードを割り当てておき、
ユーザがキーワードを入力すると、そのキーワードを含む文章を提示してくれる検索機能とします。
たとえば図\ref{fig:peks1.pdf}では、ユーザが「社外秘」というキーワードを提示すると、サーバ側でキーワードリストからそのキーワードを探索します。
そして見つかったキーワードリストに対応する文章1と文章3をユーザに伝えます。

文章などの各データは、検索時に必要がないので従来の共通鍵暗号で暗号化しておきます。
各キーワードも暗号化しましょう。
キーワード全体を$\Set{m_1, \dots, m_n}$とします。
ユーザは初期化ベクトルIV（\ref{CBC}節参照）を固定して共通鍵暗号を使ってキーワードを暗号化します。
秘密鍵$K$で全てのキーワードを暗号化してキーワードリストを作りサーバに置きます。
そしてキーワード$m$を暗号化して$\Enc(K,m)$をサーバに送ります。
サーバは$\Enc(K,m)$と$\Enc(K,m_i)$が一致するものを見つけて対応する文章を返します。
\image{peks1.pdf}{キーワード検索}

この方法はサーバが文章やキーワードの中身を見られないという利点があります。
しかしIVを固定しているので同じキーワードは同じ暗号文になります。
するとサーバはどのキーワードリストとどのキーワードリストが同じキーワードを持っているかわかります。
たとえば図\ref{fig:peks1.pdf}の例では「文章1」と「文章3」は同じキーワード（サーバはどんなキーワードかはわからない）を持っている、
「文章1」と「文章2」も「予算」（やはりサーバには中身はわからない）という同じキーワードを持っているということはわかります。

そこで安全性を高めるために同じキーワードを暗号化しても異なる暗号文になってほしいです。
単にキーワードごとにIVを変えると同じキーワードでも異なる暗号文になります。
しかし、それではサーバが二つの暗号文をみて元のキーワードが同じかどうかを判定できません。

したがって、暗号化する度に同じキーワードでも異なる暗号文になるのだけれども、
それを復号しなくてももとのキーワードが一致しているかどうかを判別することだけはできるような暗号方式が望ましいです。
こういった性質を満たすものを検索可能暗号といいます。
\image{peks2.pdf}{異なる暗号文}

なお、キーワードが一致するかを判別するのはサーバです。
だから、せっかく同じキーワードでも異なる暗号文にしたとしてもサーバにとってはどの暗号化キーワードとどの暗号化キーワードが同じかわかってしまいます。
ただ、外部の人にとってはどの暗号化されたキーワードが同じかは判らないので、うっかりサーバのデータが流出してもキーワードが推測されるリスクは減っています。
完全に秘匿する方法も提案されていますが、効率は悪いようです。
このように検索可能暗号は効率と安全性の落とし処が難しいです。

\section{キーワード検索公開鍵暗号}
2004年に提案されたキーワード検索公開鍵暗号（PEKS : Public key Encryption with Keyword Search）を紹介します~\cite{BCO}。
このアルゴリズムでは、まずAさんが公開鍵と秘密鍵を用意します。
暗号化されたキーワードが一致しているかどうかを確認する人（たとえばサーバ）をSとします。
Aは秘密鍵を用いてあるキーワード$w$に対して落とし戸と呼ばれる特別な値$T_w$を作ります。
$T_w$をSに渡します。
それからAは自身の公開鍵を用いていろいろなキーワード$w$を暗号化して$p_w$を作ります。
同じ$w$でも暗号化するたびに異なる$p_w$になります。
$p_w$は公開鍵だけで作れるので他の人が作っても構いません。
Sは与えられた$p_w$と$T_w$が同じ$w$から作られたものかどうかの確認ができます。
どんなキーワード$w$を暗号化したのかはわかりません。
詳細なアルゴリズムは次の通りです。
\mydescription{
\item[鍵生成]
楕円曲線$E$とその上の点$P$を決める。
Aは乱数$a$をとり秘密鍵$K_{\tt{priv}}$とする。
$Q:=aP$として$K_{\tt{pub}}:=(P,Q)$を公開鍵とする。
$H_1$をキーワードから$E$へのハッシュ関数、$h_2$を有限体から整数へのハッシュ関数とする。
\item[PEKS]
乱数$r$をとり、公開鍵$K_{\tt{pub}}$を用いてキーワード$w$を暗号化する。
\[
\PEKS(K_{\tt{pub}},w):=(rP, h_2(e(H_1(w), rQ))) \in E \times \ZZ.
\]
\item[落とし戸]
Aは秘密鍵$K_{\tt{priv}}$を用いてキーワード$w$に対して落とし戸を作る。
\[
\Trapdoor(K_{\tt{priv}},w):=aH_1(w).
\]
\item[テスト]
暗号化されたキーワード$p_w:=\PEKS(K_{\tt{pub}},w)=(R, h) \in E \times \ZZ$と落とし戸$T_w:=\Trapdoor(K_{\tt{priv}},w)$を用いて
\[
h_2(e(T_w,R))\eqq h
\]
が成り立てば$p_w$と$T_w$は同じ$w$に対応するものである。
}
テストの正当性は
\[
h_2(e(T_w,R))=h_2(e(aH_1(w),rP))=h_2(e(H_1(w),arP))=h_2(e(H_1(w),rQ))=h
\]
からわかります。
\section{問題点と改良}
前述のアルゴリズムはBDH仮定のもとで安全であることが示されます。
ただこのアルゴリズムの落とし戸関数は秘密鍵$a$とキーワード$w$だけから決まる決定的な関数です。
したがって、落とし戸の値を暗号化されていない状態でやりとりしていると、
盗聴者はそのデータを集めてキーワードの分布からキーワードの重要度などを推測することができるかもしれません。
そのため、落とし戸関数も確率的関数にする方法が提案されています。

また別の問題もあります。
サーバがあるキーワード$w_0$に対する落とし戸$T_{w_0}$をもらったとします。
サーバはその値から$w$を求めることはできないとされています。
しかし、PEKSは公開鍵さえあれば任意のキーワード$w$に対して求めることができます。

したがって、サーバがキーワードに使われそうな単語リストを用意して次の方法で辞書攻撃ができます。
まず、そのリストの各$w$に対してPEKS $p_w$を求めます。
落とし戸$T_{w_0}$と$p_w$に対してテストをして$w=w_0$かを確認します。
$w=w_0$になるような$w$が見つかるまで$w$を次々と変えてやり直します。

このような攻撃ができないような方法も研究されています。
また、共通鍵を使った方式SSE（Searchable Symmetric Encryption）も研究されています。

\section{この章のまとめ}
データを暗号化したまま検索する検索可能暗号の紹介をしました。
キーワードを秘匿にしたまま検索する研究では、そもそも何を隠したいのか、演算効率、想定される攻撃などについて様々なモデルが提案されています。
キーワードの完全一致ではなく部分一致に対応したものも研究されています。
これらの手法では事前に決められたキーワードのリストを使います。
そのリストが固定では使い勝手がよくありません。
リストの更新が容易にできるものが望ましいため、それらの手法も研究されています。
